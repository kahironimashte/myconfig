#+TITLE: Emacs-Konfiguration
* Allgemeine Einstellungen
:PROPERTIES:
:CATEGORY: allg
:END:
** file-settings
#+STARTUP: overview
#+TODO: TODO FEHLER  | OK DONE
.#+TAGS: Funktionen(f) deaktiviert(d) WindowsOnly(w) LinuxOnly(l) Paket(p) obsolet(o)
** Startup
   - disable splash screen and startup message
#+begin_src emacs-lisp :results output silent
(setq inhibit-startup-message t) 
(setq initial-scratch-message nil)
#+end_src
** org-directory
#+begin_src emacs-lisp :results output silent
(if (string-equal system-type "windows-nt")
    (setq org-directory "c:/org")
    (setq org-directory "~/org")
  )
#+end_src

** TODO Sicherung
*** Ordner für Autosave-Dateien
Emacs speichert Dateien wenn sie offen sind unter kryptischen Dateinamen (#datei.org# oder datei.org~). Diese machen den Ordner unübersichtlich, können aber in einem eigenen Verzeichnis angesiedelt werden. 
#+BEGIN_SRC emacs-lisp 
(setq 
   backup-by-copying t      ; don't clobber symlinks
   backup-directory-alist `(("." . ,(concat org-directory "/_config/backups/")))
   delete-old-versions t
   kept-new-versions 6
   kept-old-versions 2
   version-control t       ; use versioned backupsr 
)
#+END_SRC
** Default Modes
#+begin_src emacs-lisp :results output silent
;; Default Modes ON
(global-visual-line-mode t)

;; Fontlock Mode in jedem Buffer automatisch aktivieren.
(global-font-lock-mode t)

#+end_src

*** Saving Desktop Sessions
disabled [2023-11-19 So] because of cluttering up list - reenabled [2023-11-26 So 14:44] because alternative not yet configured
  #+BEGIN_SRC emacs-lisp
  ;; SAVING DESKTOP SESSIONS
  ;;------------------------
 (require 'desktop)
(when (eq system-type 'windows-nt)
    (desktop-change-dir "C:/Software/Emacs/Desktops/")
 )
(desktop-save-mode 1)
 #+END_SRC

 #+RESULTS:
 : t

*** Start any Windows maximised
 #+BEGIN_SRC emacs-lisp
  ;; Start any Windows maximised
  (add-to-list 'default-frame-alist '(fullscreen . maximized))
 #+END_SRC
*** Sentence end to just one space
 #+BEGIN_SRC emacs-lisp
  ;; Set Sentence end to just one space
  (setq sentence-end-double-space nil)
 #+END_SRC
** confirm with y
   #+begin_src emacs-lisp :results output silent
(fset 'yes-or-no-p 'y-or-n-p)
   #+end_src
** loop over headlines in active regions
#+begin_src emacs-lisp :results output silent
(setq org-loop-over-headlines-in-active-region t)
#+end_src
** makros
   #+begin_src emacs-lisp :results output silent
  (fset 'macro-statusnow
	(lambda (&optional arg) "Keyboard macro." (interactive "p") (kmacro-exec-ring-item (quote (" er uuzTns" 0 "%d")) arg)))
 (global-set-key (kbd "<f6>")  'macro-statusnow)
   #+end_src
   - [2021-09-20 Mo] : war " er uuzTns   " , zwei mal nach unten und expansion.
** Keyboard-Shortcuts :keys:
 - [[*Agenda custom commands][Agenda custom commands]]
*** for org-agendas
ausgelagert in eigene Datei
 - Linux [[file:~/org/_config/emacs/customagendas.org::*Keyboard-Shortcuts][Keyboard-Shortcuts]]
*** for org-columns
#+begin_src emacs-lisp :results output silent
(with-eval-after-load "org-colview"
  (define-key org-columns-map (kbd "a") nil)
  (define-key org-columns-map (kbd "o") nil)
  (define-key org-columns-map (kbd "c") nil)
  (define-key org-columns-map (kbd "n") nil)
  (define-key org-columns-map (kbd "p") nil)
  (define-key org-columns-map (kbd "g") nil)
)
#+end_src
*** allgemein
#+begin_src emacs-lisp :results output silent
;; Escape-Command - use ESC for Ctrl + g
(define-key key-translation-map (kbd "ESC") (kbd "C-g"))
(define-key key-translation-map (kbd "C-<escape>") (kbd "ESC"))
#+end_src
  | Key | function        |   |
  |-----+-----------------+---|
  | F6  | [[*makros][makro-statusnow]] |   |
  |     |                 |   |
**** org-mode
#+begin_src emacs-lisp :results output silent
 (global-set-key "\C-cl" 'org-store-link)
 (global-set-key "\C-ca" 'org-agenda)
 (global-set-key "\C-cc" 'org-capture)
#+end_src

** Archive-Location 
#+begin_src emacs-lisp :results output silent
(setq org-archive-location (concat org-directory "/archiv/%s_archive::datetree/"))
#+end_src

** Inline-Images :appearance:
   - Die Breite des Bildes kann gesetzt werden über =#+ATTR_ORG: :width 100= in der Zeile über dem Link.
 
#+begin_src emacs-lisp :results output silent
(setq org-image-actual-width nil)
#+end_src

* Pakete :package:
** ausprobieren
*** TODO Minimap
*** TODO Neotree
*** TODO valign 
** COMMENT deaktivierte Pakete
*** COMMENT ido-mode :navigation:
 - [ ] Prots Empfehlung "icmoplete" ist besser integriert ab emacs 27.1 -> nachfolger von ido.
 - Wenn man weiß, wohin man will. 
**** Beschreibung
 This is the built-in framework for interactively narrowing down the
 list of matching candidates when performing a relevant search.  Ido
 underpins functions such as those that change buffers, navigate the
 filesystem, query for help…  I used to be an Ivy user, but have found
 that Ido is just as good for my case.  Plus, I prefer its default
 horizontal layout.  Simple and effective.

 Here is an overview of my configurations:

 + Use =ido-mode= and make sure it runs everywhere it can.
 + Enable "flexible matching".  If there is no matching string of
   adjacent characters, Ido will instead search for any item containing
   the characters in their given sequence even if they are not
   positioned directly next to each other.  Their sequence is all that
   matters.
 + Also disable regexp and prefix matching by default.  These can be
   toggled on at any moment with =C-t= or =C-p= respectively (read
   below for more key bindings).
 + Only consider the current frame.  I seldom use more than one (recall
   that what Emacs calls "frames" is what window managers call
   "windows").
 + Create a buffer with completion candidates (manually invoke it with
   "?" after having typed a search), but do not place all completions
   there—just the current list of matches.
 + No need to confirm anything when there is a unique match.
 + Create a buffer when there is no match for the given search.  Ask for
   confirmation.  This is great for producing a scratch-like buffer,
   whose contents can then be saved with =C-x C-s= or =C-x C-w=.
 + By default open matching buffers and files in the selected window.
   I use separate commands for doing the same for the "other window".
   By default, these are always accessed via =C-x 4=.
 + Keep track of selected directories (recall that navigating history
   is done with =M-n= and =M-p=).
 + Do not try to guess whether the symbol at point is a file name.
   This gives many false positives and consequently hampers the
   commands for filesystem navigation.
 + Same for URLs.
 + Use "virtual buffers" (e.g. recent files without a current buffer).
   I also have a separate key binding for that (see my =use-package=
   declaration for =recentf=).
 + Allow the theme's styles for Ido.  I have configured those in my
   Modus themes (defined elsewhere in this document).
 + Keep the prompt to a single line.  I find that a horizontal layout
   that spans multiple lines is counter-productive.  One line is nice
   and simple.  We are anyhow going to narrow down the list of
   candidates by typing a search.  The =:hook= for the minibuffer ensures
   that this aesthetic is not anyhow interfered with.
 + As for =ido-decorations= it is better you search for its help buffer
   with =C-h v ido-decorations RET=.  Basically, I tweak it to have
   less visual noise.
 + Do not allow Ido to employ its "merge" functionality.  What that does
   is to automatically switch directory if the file name you type in does
   not exist in the current directory but is available in some other
   place you recently visited.  This makes it difficult to just create a
   new file.  By the by, when using =ido-find-file= you can always just
   confirm the inserted text with =C-j=.

 Then I just bind some common commands to the Super key.  Where you see
 a capital letter, it means Super-Shift-KEY.  For a complete overview
 of some useful key bindings, type =C-h f ido-find-file RET=.  The
 bindings I define in =ido-common-completion-map= are for consistency
 with their equivalents in =isearch=.
**** code
#+begin_src emacs-lisp :results output silent
(use-package ido
  :custom
  (ido-everywhere t)
  (ido-enable-flex-matching t)
  (ido-enable-regexp nil)
  (ido-enable-prefix nil)
  (ido-all-frames nil)
  (ido-buffer-disable-smart-matches t)
  (ido-completion-buffer "*Ido Completions*")
  (ido-completion-buffer-all-completions nil)
  (ido-confirm-unique-completion nil)
  (ido-create-new-buffer 'prompt)
  (ido-default-buffer-method 'selected-window)
  (ido-default-file-method 'selected-window)
  (ido-enable-last-directory-history t)
  (ido-use-filename-at-point nil)
  (ido-use-url-at-point nil)
  (ido-use-virtual-buffers t)
  (ido-use-faces t)
  (ido-max-window-height 1)
  (ido-decorations
   '(" "
     "   "
     " | "
     " | …"
     "["
     "]"
     " [No match]"
     " [Matched]"
     " [Not readable]"
     " [Too big]"
     " [Confirm]"
     " "
     " "))
  (ido-auto-merge-work-directories-length -1)
  :config
  (ido-mode 1)
)

;;The following ensures that Ido mode is implemented in as many places as possible.  I am not sure what is not covered by it, but so far every relevant interface provides Ido-style matching.

(use-package ido-completing-read+
  :ensure t
  :after ido
  :config
  (ido-ubiquitous-mode 1))
#+end_src

*** COMMENT org-roam
- alternative form Prot (demo Video): =denote=
download sqlite3 and add it to exe-path, confir with (executable-find "sqlite3")
#+begin_src emacs-lisp :results output silent
    (when (string-equal system-type "windows-nt")
      (add-to-list 'exec-path "C:/Software/SQLite")
      (setq org-roam-directory "C:/org/roam")
;;      (setq org-roam-db-update-method 'immediate)
;;      (add-hook 'after-init-hook 'org-roam-mode)
      )

#+end_src
*** COMMENT doom-modeline :appearance:
#+BEGIN_SRC emacs-lisp
  (use-package doom-modeline
    :init (doom-modeline-mode 1)
    :custom (doom-modeline-height 5))
  (use-package all-the-icons)
#+end_src
**** Fix der Modeline-Höhe von [[https://github.com/seagle0128/doom-modeline/issues/187][hier]]
#+begin_src emacs-lisp :results output silent
(defun my-doom-modeline--font-height ()
  "Calculate the actual char height of the mode-line."
  (+ (frame-char-height) 2))
(advice-add #'doom-modeline--font-height :override #'my-doom-modeline--font-height)
#+END_SRC
*** COMMENT Emacs Startup Profiler - ESUP
   #+begin_src emacs-lisp :results output silent
     (use-package esup
       :ensure t
       ;; To use MELPA Stable use ":pin melpa-stable",
       ;;:pin melpa
       )   
#+end_src
*** TODO [#B] COMMENT Smartparens
 - Paket um Klammern etc. zu vervollständigen.
#+BEGIN_SRC emacs-lisp
(require 'smartparens)
(require 'smartparens-config)   
(define-key smartparens-mode-map (kbd "M-<backspace>") 'sp-unwrap-sexp)
(define-key smartparens-mode-map (kbd "S-<backspace>") 'sp-backward-unwrap-sexp)
#+END_SRC
This is bold and that is bolder. 
** olivetti-mode :appearance:
Zentriert den Text in einer schmaleren Spalte, um das Lesen zu vereinachen. Der Modus wird nur aktiviert, wenn eine gewisse Buffer-Breite anzeigbar ist.
#+begin_src emacs-lisp
(use-package olivetti
  :ensure t
  :config
  (setq olivetti-style 'fancy) ;; use margins
  (setq olivetti-body-width 54)
  )
#+end_src


** COMMENT key-cast-mode
#+begin_src emacs-lisp
(use-package keycast
  :ensure t
  :config
  ;; (dolist (input '(self-insert-command org-self-insert-command))
  ;;   (add-to-list 'keycast-substitute-alist `(,input "." "Typing…")))
  ;; 
  ;; (dolist (event '(mouse-event-p mouse-movement-p mwheel-scroll))
  ;;   (add-to-list 'keycast-substitute-alist `(,event nil)))
  ) 
#+end_src

#+RESULTS:

** COMMENT repeat-mode
Package is built-in.
Only works for commands, that are designed to work with it. The function goes through the emacs object map and searches for the repeat-property.

#+begin_src emacs-lisp :results output silent
(use-package repeat
  :ensure nil ; built-in
  :config
  (repeat-mode 1)) 
#+end_src

*** COMMENT explanation
the =obarray= is a huge array with all the =symbols= that emacs knows about. It's huge.

We want to filter out all the symbols with the "=repeat-map= property.
#+begin_src elisp
(get 'other-window 'repeat-map)  ;; => other-window-repeat-map

#+end_src
#+begin_src emacs-lisp
;; This function and the `let' one below are the better way:
(defun my-command-is-repeatable-p (symbol)
  "Return non-nil if SYMBOL is a repeatable command."
  ;; =commandp= checks if =symbol= is a command, so that we can repeat it. 
  (and (commandp symbol)
       (get symbol 'repeat-map)))
;; check if the symbol has the repeat-map property.)

;; We could also use a =defun= arround this let to make the code interactive.
(let ((repeatable-collection))
  (mapatoms
   ;; calls every symbol in a specific obarray, which defaults to the emacs obarray
   (lambda (symbol)
     ;; is anonymous, becaus we just call it inside this loop. We don't want to reuse it outside the loop
     ;; two conditions: symbol must be a command and have the =repeat-map= property.
     (when (my-command-is-repeatable-p symbol)
       (push symbol repeatable-collection))))
  	   ;; add the result to the collection =repeatable=
  repeatable-collection)
  ;; returns the collection =repeatable=
#+end_src

#+RESULTS:
| undo                             |
| outline-demote                   |
| shrink-window                    |
| other-window                     |
| shrink-window-horizontally       |
| outline-next-visible-heading     |
| tab-previous                     |
| tab-move                         |
| next-error                       |
| previous-error                   |
| tab-next                         |
| tab-bar-move-tab-backward        |
| outline-previous-visible-heading |
| enlarge-window-horizontally      |
| outline-backward-same-level      |
| outline-forward-same-level       |
| outline-promote                  |
| forward-page                     |
| backward-page                    |
| outline-up-heading               |
| enlarge-window                   |
| outline-move-subtree-down        |
| outline-move-subtree-up          |

org-table-transpose-table-at-point

#+begin_src emacs-lisp
;; Not so good way of achieving the same result: Because symbols are not checked, and there can be double entries, because functions and variables with the same name can coexist.
(let ((collection))
  (mapatoms
   (lambda (symbol)
     ;; (and (commandp symbol)
     ;;      (get symbol 'repeat-map))
     (push (get symbol 'repeat-map) collection)))
  (delq nil collection))

;; Fuction delq explained
(delq nil '(nil one nil two nil three))
;; => (one two three)

;; Function delet-dups explained
(delete-dups '(one one two two three three))
;; => (one two three) 
#+end_src		

*** configuration of repeatable commands
Repeat mode checks if the command has a value for the repeat-map. And then it checks this kemap and finds the key to activate the function with a single key.
Repeat-mode -> look at =command=, if it has =repeat= property, activate the keymap =value of repeat property=. -> Keymap is activated and can contain a complete modal editing layer.

[ COMMAND ] --find repeat map--> [ REPEAT KEYMAP ] --find key of the command--> [ KEY ] --use the key again--> [ COMMAND ] 

_Hint:_ If we want all the commands available in the same repeat key-map we just add them to the same repeat-key-map. If we do not want them available, we have to define the command in a separate repeat-keymap.
#+begin_src emacs-lisp
;; The `defvar-keymap' is for Emacs 29+. or with the compat pakage to use newer commands in older emacs-versions (comes with for ex. with vertico)
(defvar-keymap my-org-repeat-map ;; <-- emacs calls this keymap location
  :repeat t
  "l" #'org-forward-heading-same-level
  "h" #'org-backward-heading-same-level 
  "n" #'org-next-visible-heading
  "p" #'org-previous-visible-heading
  "o" #'other-window
  )



#+end_src

#+RESULTS:
: my-org-repeat-map

instead of =map "n"= we could use multi-key-commands with =(kbd "C-n")=, but not =(kbd "n o")= for a sequence.

#+begin_example emacs-lisp
;; Same as above for Emacs 28
(defvar my-org-repeat-map
  (let ((map (make-sparse-keymap)))
    (define-key map "n" #'org-next-visible-heading)
    (define-key map "p" #'org-previous-visible-heading)
    map))

(put #'org-next-visible-heading 'repeat-map 'my-org-repeat-map)
(put #'org-previous-visible-heading 'repeat-map 'my-org-repeat-map) 
#+end_example
_Hint:_ use begin_example instead of begin_src to not tangle a block.
** Vertico UI :prot:navigation:interface:
#+begin_src emacs-lisp
(use-package vertico
  :ensure t
  :config
  (setq vertico-count 10)
  (setq vertico-resize nil)
  (setq vertico-cycle t)

  (vertico-mode 1))

;; (ido-mode -1) ;; deactivated ido mode for this to work [2023-06-11 So]
#+end_src

#+RESULTS:
: t
*** marginalia UI
Completion information Package
#+begin_src emacs-lisp
(use-package marginalia
  :ensure t
  :config
  (marginalia-mode 1)) 
#+end_src

#+RESULTS:
: t
** orderless :search:navigation:prot:completion:
We can also use regular expressions for search.
#+begin_src emacs-lisp
(use-package orderless
  :ensure t
  :config
  (setq orderless-matching-styles
        '(orderless-prefixes orderless-flex orderless-regexp)) ;; Types of patterns, that orderless tries to use.

  (setq completion-styles '(emacs22 substring orderless) ;; two completion styles =emacs22= then =substring= then =orderless= is first used then =basic=
	)
  (setq completion-category-overrides 
        ;; NOTE 2021-10-25: I am adding `basic' because it works better as a
        ;; default for some contexts.  Read:
        ;; <https://debbugs.gnu.org/cgi/bugreport.cgi?bug=50387>.
        ;;
        ;; `partial-completion' is a killer app for files, because it
        ;; can expand ~/.l/s/fo to ~/.local/share/fonts.
        ;;
        ;; If `basic' cannot match my current input, Emacs tries the
        ;; next completion style in the given order.  In other words,
        ;; `orderless' kicks in as soon as I input a space or one of its
        ;; style dispatcher characters.
        '((file (styles . (basic partial-completion orderless)))
          (project-file (styles . (basic substring partial-completion orderless)))
          (imenu (styles . (basic substring orderless)))
          (kill-ring (styles . (emacs22 substring orderless)))
          (consult-location (styles . (basic substring)))
          (eglot (styles . (emacs22 substring orderless))))) 

  ;; Ignore case in searches. # case-fold
  (setq completion-ignore-case t)
  (setq read-buffer-completion-ignore-case t)
  (setq read-file-name-completion-ignore-case t)
  (setq-default case-fold-search t)   ; For general regexp   
  )
#+end_src

#+RESULTS:
: t
** savehist :search:prot:builtin:
#+begin_src emacs-lisp
(use-package savehist
  :ensure nil ; built-in
  :config
  (savehist-mode 1))
#+end_src

**  consult :search:navigation:prot:
Jumping to Headings  or lines.

 - [ ] imenu functionality
 - [ ] explore config-options: change behaviour context specific
#+begin_src emacs-lisp
(use-package consult
  :ensure t
  :config
  (ryo-modal-keys
   ("s" (
	 ("j" consult-outline)
	;; ("f" consult-find) ;; ist für Projekte/Dateisuche
	;; ("g" consult-grep)
	;;  ("h" consult-history) ;; ERROR: No conulst-histories configured for org-mode
	 ("l" consult-line)
	 ("m" consult-mark)
	 ("y" consult-yank-pop))))

   ;; Use C-s in the minibuffer to search through its history:

   ;; Use C-s to search the history of the specific minibuffer (shell, magit, M-x, ...)
   (define-key minibuffer-local-map (kbd "C-s") #'consult-history)
   ) 
#+end_src

#+RESULTS:
: t

*** COMMENT Prots Presets
#+begin_src emacs-lisp
(define-key global-map (kbd "M-s M-b") 'consult-buffer)
  (define-key global-map (kbd "M-s M-f") 'consult-find)
  (define-key global-map (kbd "M-s M-g") 'consult-grep)
  (define-key global-map (kbd "M-s M-h") 'consult-history)
  (define-key global-map (kbd "M-s M-l") 'consult-line)
  (define-key global-map (kbd "M-s M-m") 'consult-mark)
  (define-key global-map (kbd "M-s M-s") 'consult-outline)
  (define-key global-map (kbd "M-s M-y") 'consult-yank-pop) 
#+end_src

** corfu
for in-buffer-completion
#+begin_src emacs-lisp
;; In-buffer completion
(use-package corfu
  :ensure t
  :config
  (setq-default tab-always-indent 'complete)
  (add-hook 'prog-mode-hook #'corfu-mode)

  (setq corfu-popupinfo-delay '(2.0 . 1.0))
  (corfu-popupinfo-mode 1) ; subject to `corfu-popupinfo-delay'

  (define-key corfu-map (kbd "<tab>") #'corfu-complete)

  ;; Adapted from Corfu's manual.
  (defun contrib/corfu-enable-always-in-minibuffer ()
    "Enable Corfu in the minibuffer if Vertico is not active.
Useful for prompts such as `eval-expression' and `shell-command'."
    (unless (bound-and-true-p vertico--input)
      (corfu-mode 1)))

  (add-hook 'minibuffer-setup-hook #'contrib/corfu-enable-always-in-minibuffer 1)) 
#+end_src

#+RESULTS:
: t

** COMMENT corfu :prot:completion:
 - merge with other corfu-heading In -Buffer-Completion
#+begin_src emacs-lisp
(use-package corfu
  :ensure t
  :config
  (setq-default tab-always-indent 'complete)
  
  (global-corfu-mode 1)

  (corfu-popupinfo-mode 1) ; shows documentation after `corfu-popupinfo-delay'

  (define-key corfu-map (kbd "<tab>") #'corfu-complete)

  ;; Adapted from Corfu's manual.
  (defun contrib/corfu-enable-always-in-minibuffer ()
    "Enable Corfu in the minibuffer if Vertico is not active.
Useful for prompts such as `eval-expression' and `shell-command'."
    (unless (bound-and-true-p vertico--input)
      (corfu-mode 1)))

  (add-hook 'minibuffer-setup-hook #'contrib/corfu-enable-always-in-minibuffer 1)) 
#+end_src

#+RESULTS:
: t

** TODO vundo History manager :emacs28:navigation:
#+begin_src emacs-lisp
;; Requires Emacs 28
(use-package vundo
  :ensure t
  :config
  (setq vundo-glyph-alist vundo-unicode-symbols)
  (define-key global-map [remap undo] 'vundo)) ;; remap vundo to undo
#+end_src

#+RESULTS:
: t

** org-clock-convenience :clocking:orga:
 - [[https://github.com/dfeich/org-clock-convenience/blob/master/README.org][Github-Source]]
#+begin_src emacs-lisp :results output silent
(use-package org-clock-convenience
  :ensure t
  :bind (:map org-agenda-mode-map
   	   ("<C-up>" . org-clock-convenience-timestamp-up)
   	   ("<C-down>" . org-clock-convenience-timestamp-down)
   	   ("<f6>" . org-clock-convenience-fill-gap)
   	   ("<f7>" . org-clock-convenience-fill-gap-both)))
#+end_src
*** Interactive functions
  - =org-clock-convenience-timestamp-up= and =org-clock-convenience-timestamp-down=:
    When on a /clocked/ line in the agenda buffer, this function will
    increase/decrease the time according to the position of the
    cursor. If the cursor is on the hour field, change the hour. If it
    is on the minutes field, change the minutes. Undo works on the
    agenda and on the source buffer.
  - =org-clock-convenience-fill-gap= modifies the timestamp at point to
    connect to the previous/next logged time range.
  - =org-clock-convenience-fill-gap-both= connects both timestamps of
    the current clock log line at point to fill the interval between
    the previous and the next clock range. The cursor need not be on a
    timestamp of the line. This is the most efficient way to fill the
    interval for a forgotten task.
  - =org-clock-convenience-goto-ts= goto the associated timestamp in the org
    file. Position the cursor respective to where the cursor was
    placed in the agenda view (e.g. on the minutes part of the
    starting time).
  - =org-clock-convenience-goto-last-clockout=: goto timestamp of the last
    clockout (this is based on a real search through the buffer and
    not based on the saved clockout value).

  Note that the agenda clock changing commands work with *undo* in the
  same way as other org agenda commands. They will undo in the agenda
  buffer as well as in the org source buffers. But if the agenda
  buffer is rebuilt after a change (e.g. by =g=), the undo information
  is lost.
  
  The package also contains a number of utility functions to associate
  a list with field names with the subgroup of a regular expression and
  position point at a named field or read its value.
** unfill (paragraph/region) :appearance:
 - Source: https://github.com/purcell/unfill
 - Install via Melpa
#+begin_src emacs-lisp
(use-package unfill)
#+end_src
Commands: 
M-x unfill-region
M-x unfill-paragraph
M-x unfill-toggle
** anki-editor :learning:
- Vouraussetzungen:
  1. =sudo apt install anki curl=
  3. Anki Addon Code: =2055492159= eintippen unter "Addons" / Get Addons
  4. Log in bei =ankiweb.net= via E-Mail und Passwort
#+begin_src emacs-lisp :results output silent
  (use-package anki-editor
    :config
    (setq anki-editor-create-decks t ;; Allow anki-editor to create a new deck if it doesn't exist
	  anki-editor-org-tags-as-anki-tags t)
  )
#+end_src

** dired :system:
*** hide-details-mode
Standardmäßig alle Details außer Dateinamen ausblenden - umschaltbar mit Taste =(=
#+begin_src emacs-lisp :results output silent
(add-hook 'dired-mode-hook
	  (lambda()   ;; mostly appropriate to call more than one function.
	    (dired-hide-details-mode 1)
	  )
     )
(setq ls-lisp-dirs-first t) ;; Ordner in Dired zuerst anzeigen
#+end_src

**** COMMENT alterative solution
What this does is the same as above but without writing the lambda. It is an easyer synthax. Hooks always call functions and modes are functions (and variables)
#+begin_src emacs-lisp :results output silent
(add-hook 'dired-mode-hook 'dired-hide-details-mode) 
#+end_src

*** nerd-icons-dired-mode
before first use: M-x =nerd-icons-install-fonts= and restart
#+begin_src emacs-lisp :results output silent
(use-package nerd-icons-dired
  :ensure t
  :config 
  ;; vv siehe alternative solutions
  (add-hook 'dired-mode-hook #'nerd-icons-dired-mode))
#+end_src

*** dwim-copy
When you try to copy to a place that doesn't exist, it creates the directory right away.
#+begin_src emacs-lisp :results output silent
(setq dired-recursive-copies 'always)
(setq dired-recursive-deletes 'always)
(setq dired-create-destination-dirs 'ask) 
#+end_src
** imenu-anywhere :navigation:
#+begin_src emacs-lisp :results output silent
  (use-package imenu-anywhere
    :config
    (setq org-imenu-depth 2) ;; Wie tiefe Headings ansteuerbar sind.
)

  ;; (defvar push-mark-before-goto-char nil)

  ;; (defadvice goto-char (before push-mark-first activate)
  ;;    (when push-mark-before-goto-char
  ;;       (push-mark)))

  ;; (defun ido-imenu-push-mark ()
  ;;    (interactive)
  ;;    (let ((push-mark-before-goto-char t))
  ;;       (ido-imenu)))
#+end_src
** Nov-mode :content:
   - Paket um epub-Dateien in Emacs zu lesen.
#+begin_src emacs-lisp :results output silent
  (use-package nov
    :mode ("\\.epub\\'" . nov-mode))
  (when (string-equal system-type "windows-nt")
    ;; Set unzip location for nov.el
    (setq nov-unzip-program "C:\\Software\\Emacs\\_unzip-Package\\bin\\unzip.exe")
    )

#+end_src

- für Libre Office Export:
  1. Zip für Libre Office-Export installieren: 

     + unzip.exe und zip.exe müssen im selben Ordner sein. 
     + Pfad anlegen: M-x customize-variable RET exec-path RET
     + Pfad Ziel: C:/Software/Emacs/_unzip-Package/zip  
  2. Libre Office Portable installieren
** org-bookmark-heading :navigation:
** TODO org-transclusion :content:
to include parts of Text from other documents (with sync-option)

installed [2023-07-01 Sa]
#+begin_src emacs-lisp
(use-package org-transclusion
  :ensure t
)
#+end_src

#+RESULTS:
** transient-mode
#+begin_src emacs-lisp
(use-package transient
  :ensure t
  :config
  (transient-define-prefix prot-prefix-file nil
    "Transient with file commands."
    [["File or directory"
      ("f" "find-file" find-file)
      ("F" "find-file-other-window" find-file-other-window)
      ("s" "sechond transient buffer" prot-prefix-test)]
     ["Directory only"
      ("d" "dired" dired)
      ("D" "dired-other-window" dired-other-window)]]
     ["Documentation"
      ("l" "find-library" find-library)
      ("m" "man" man)])

  (transient-define-prefix prot-prefix-test nil
    "Transient with file commands."
    ["second transient buffer"
      ("q" "find-file" find-file)
      ("Q" "find-file-other-window" find-file-other-window)]))
#+end_src

#+RESULTS:
: t

Value after the face is =set for the frame=. Nil means all frames.
=list-frames= lists all the frames. You can select a specific frame. A
symbol semantically represents the "proper name" while a string is
"just" a vector of characters with no explicit meaning. This is a
convention, not enforced in the code.
#+begin_src emacs-lisp
(set-face-attribute 'transient-key nil :foreground "dark magenta" :weight 'bold)
(set-face-attribute 'transient-heading nil :underline t :weight 'unspecified)
#+end_src

#+RESULTS:
*** Ressources
 - showcase: https://github.com/positron-solutions/transient-showcase
 - Manual: https://magit.vc/manual/transient/
 - Manual in info-mode: [[info:transient#Top][transient#Top]]

** TODO org-remark :content:
... is a package to annotate org-files

installed [2023-07-01 Sa]
#+begin_src emacs-lisp
(use-package org-remark
  :ensure t
  :config
  (org-remark-global-tracking-mode +1)

#+end_src

*** _Define highlighters_
... for different purposes and different styles:
1. higlighter face
2. create higligher  

Each highlighter uses a category to filter the marginalia file by. 
#+begin_src emacs-lisp
  (defface org-remark-highlighter-background-info
    '((((class color) (min-colors 88) (background light))
       :underline "RoyalBlue4" :background "LightSkyBlue1")
      (((class color) (min-colors 88) (background dark))
       :underline "LightSkyBlue1" :background "RoyalBlue4")
      (t
       :inherit highlight))
    "Face for the highlighter pen that marks background information.")
  (org-remark-create "hintergrund"
                     'org-remark-highlighter-background-info
                     '(CATEGORY "background" help-echo "Good to know"))

  (defface org-remark-highlighter-action
    '((((class color) (min-colors 88) (background light))
       :underline "forest green" :background "pale green")
      (((class color) (min-colors 88) (background dark))
       :underline "pale green" :background "dark green")
      (t
       :inherit highlight))
    "Face for the highlighter pen that marks calls to action.")
  (org-remark-create "calltoaction"
		     'org-remark-highlighter-action
		     '(CATEGORY "action" help-echo "This is how to do it"))

  (defface org-remark-highlighter-warning
    '((((class color) (min-colors 88) (background light))
       :underline "chocolate" :background "LightSalmon1")
      (((class color) (min-colors 88) (background dark))
       :underline "LightSalmon1" :background "chocolate4")
      (t
       :inherit highlight))
    "Face for the highlighter pen that marks calls to action.")
  (org-remark-create "warning"
		     'org-remark-highlighter-warning
		     '(CATEGORY "waring" help-echo "Pay Attention to this!"))

    (defface org-remark-highlighter-clarify
    '((((class color) (min-colors 88) (background light))
       :underline "DeepPink4" :background "LightPink1")
      (((class color) (min-colors 88) (background dark))
       :underline "LightPink1" :background "DeepPink4")
      (t
       :inherit highlight))
    "Face for the highlighter pen that marks unclear points, that sould be clarified.")
  (org-remark-create "clarify"
		     'org-remark-highlighter-clarify
		     '(CATEGORY "clarify" help-echo "I need to clarify this."))

    (defface org-remark-highlighter-share
    '((((class color) (min-colors 88) (background light))
       :underline "gray35" :background "gray81")
      (((class color) (min-colors 88) (background dark))
       :underline "gray81" :background "gray35")
      (t
       :inherit highlight))
    "Face for the highlighter pen that marks content that I would like to share with somebody.")
  (org-remark-create "share"
		     'org-remark-highlighter-share
		     '(CATEGORY "clarify" help-echo "I could share this with someone."))  

#+end_src

*** file-name-function
#+begin_src emacs-lisp
(setq org-remark-notes-file-name 'my/org-remark-notes-file-name-function)

(defun my/org-remark-notes-file-name-function ()
  "Return a marginal notes file name for the current buffer.

This is the default function for the customizing variable
`org-remark-notes-file-name' for its function option.

When the current buffer is visiting a file, the name of marginal
notes file will be \"FILE-notes.org\", adding \"-notes.org\" as a
suffix to the file name without the extension.

If the current buffer is not visiting a file, the file name will
be marginalia.org in your `user-emacs-directory'.  If this file
name is not suitable, either override the function or set the
user option to use your own custom function."
  (if buffer-file-name
      (let ((source-filename (org-remark-source-find-file-name)))
        (when (and (stringp source-filename)
                   (file-exists-p source-filename))
          (concat "marginalia-"
		  (file-name-sans-extension
                   (file-name-nondirectory source-filename))
                  ".org")))
    ;; If buffer is not visiting a file, we use the default file name.
    ;; If this file name is not suitable, either override the function
    ;; or set the user option to a custom function.
    (expand-file-name "marginalia.org" user-emacs-directory)))

#+end_src

#+RESULTS:
: my/org-remark-notes-file-name-function

*** Define transient-buffers
... to quickly select org-remark features and higlihgters
#+begin_src emacs-lisp
  (transient-define-prefix my/org-remark-prefix nil
    "Transient with org-remark commands."
    [["Highlighter"
      ("a" "action" org-remark-mark-calltoaction)
      ("h" "Hintergrund" org-remark-mark-hintergrund)
      ("w" "warning" org-remark-mark-warning)
      ("c" "clarify" org-remark-mark-clarify)
      ("s" "share" org-remark-mark-share)]
     ["Navigate annotations"
      ("n" "go to next annotation" org-remark-view-next)
      ("p" "go to previous annotation" org-remark-view-prev)
      ("v" "view higlight at point" org-remark-view)      
      ("o" "open notes file at point" org-remark-open)]
     ["Edit annotations"
      ("x" "delete annotation" org-remark-delete)
      ("r" "remove annotation, keep notes" org-remark-remove)    ;; delete notes with C-u prefix
      ("s" "switch highlighter" org-remark-change)]])
)
#+end_src

#+RESULTS:
| [1 transient-columns nil ([1 transient-column (:description Highlighter) ((1 transient-suffix (:key a :description action :command org-remark-mark-calltoaction)) (1 transient-suffix (:key h :description Hintergrund :command org-remark-mark-hintergrund)) (1 transient-suffix (:key w :description warning :command org-remark-mark-warning)) (1 transient-suffix (:key c :description clarify :command org-remark-mark-clarify)) (1 transient-suffix (:key s :description share :command org-remark-mark-share)))] [1 transient-column (:description Navigate annotations) ((1 transient-suffix (:key n :description go to next annotation :command org-remark-view-next)) (1 transient-suffix (:key p :description go to previous annotation :command org-remark-view-prev)) (1 transient-suffix (:key v :description view higlight at point :command org-remark-view)) (1 transient-suffix (:key o :description open notes file at point :command org-remark-open)))] [1 transient-column (:description Edit annotations) ((1 transient-suffix (:key x :description delete annotation :command org-remark-delete)) (1 transient-suffix (:key r :description remove annotation, keep notes :command org-remark-remove)) (1 transient-suffix (:key s :description switch highlighter :command org-remark-change)))])] |

** steam :orga:
   - Importiert die Steam-Spiele als org-mode Liste.
#+BEGIN_SRC emacs-lisp
(when (string-equal system-type "gnu/linux")
 (use-package steam)
 (setq steam-username "mec4nic") ;; Replace Username with your steam username
)
#+END_SRC
steam.el can not get a list of your games unless your Steam profile is public. Visit https://steakmcommunity.com/id/username/edit/settings (where username is replaced with your Steam username). Set your profile to Public and make sure that Game details is set to Public.
Usage

    To launch a game: M-x steam-launch
    To insert your game list in org-mode format: M-x steam-insert-org-text
    Download logotypes for your games, and insert them into org-mode: M-x steam-insert-org-images
    To update your game list (if you’ve installed new games without restarting Emacs): M-x steam-get-games

In org-mode, you can click links in order to run your games. This will bring up a pop-up, asking if it is safe to run the lisp-code. If this annoys you, put this line at the top of your .org-file: #-*- org-confirm-elisp-link-function: nil; -*-

If you insert the logotype images into org-mode, make sure to turn on org-display-inline-images. You can also put #+STARTUP:inlineimages at the top of your .org-file.
** minion-mode :appearance:
Use =minions= to hide all minor modes

H. R. S: I never want to see a minor mode, and manually adding =:diminish= to every
use-package declaration is a hassle. This uses =minions= to hide all the minor
modes in the modeline. Nice!

By default there's a =;-)= after the major mode; that's an adorable default, but
I'd rather skip it.

#+begin_src emacs-lisp
   (use-package minions
     :config
     (setq minions-mode-line-lighter ""
           minions-mode-line-delimiters '("" . ""))
     (minions-mode 1))
#+end_src
** which-key :help:
 #+begin_src elisp
(use-package which-key
  :config (which-key-mode))
#+end_src
** yaml-mode :coding:
   - für espanso config-files.
#+begin_src emacs-lisp :results output silent
(use-package yaml-mode)
#+end_src
** yasnippet :content:
#+begin_src emacs-lisp :results output silent
(when (string-equal system-type "windows-nt")
  ;; Yasnippet unter Windows global aktivieren und das Verzeichnis für Snippets bestimmen.
  (use-package yasnippet
   :config
   (add-to-list 'yas-snippet-dirs "C:/org/_config/yasnippets/")
   (yas-global-mode 1)
  )
)
(when (string-equal system-type "gnu/linux")
  ;; Yasnippet unter Windows global aktivieren und das Verzeichnis für Snippets bestimmen.
  (use-package yasnippet
   :config
   (add-to-list 'yas-snippet-dirs (concat org-directory "/_config/yasnippets"))
   (yas-global-mode 1)
))
#+end_src

Aus Video Tutorial: https://www.youtube.com/watch?v=xmBovJvQ3KU Soll gut sein, um Snippets zwischen verschiedenen Modes zu teilen. 
(add-hook 'yas-minor-mode-hook (lambda ()
                                                                 (yas-activate-extra-mode 'fundamental-mode)))
* Org Mode Settings
:PROPERTIES:
:CATEGORY: org
:END:
** Coding
#+begin_src emacs-lisp
(setq org-src-preserve-indentation t)
#+end_src
** [#B] Funktionen zur Fokussierung
*** Alles einklappen außer aktuellen Subtree
   - inspiriert von [[https://emacs.stackexchange.com/questions/29304/how-to-show-all-contents-of-current-subtree-and-fold-all-the-other-subtrees][hier]]
 #+BEGIN_SRC emacs-lisp
 (defun ess/org-show-just-me (&rest _)
   "Fold all other trees, then show direct children of current org-heading."
   (interactive)
   (org-overview)
   (org-reveal)
   (org-show-children)
 )
 (add-hook 'org-after-sorting-entries-or-items-hook 'ess/org-show-just-me)

 #+END_SRC
*** Nur Todos direkt unter der Überschrift anzeigen
 #+BEGIN_SRC emacs-lisp
 (defun my-sparse-subtree-todo-search ()
   (interactive)
   (org-narrow-to-subtree)
   (let ((level (org-current-level)))
     (org-match-sparse-tree  t (format "+LEVEL=%d" (1+ level)))))
 #+END_SRC
*** Zeige nur spezielle TODOs und fokussiere den Ast
 #+BEGIN_SRC emacs-lisp

 (defun kahiro-show-todos-in-subtree ()
    "Narrow to a subtree and show only headings with TODO keywords"
    (interactive)
    (org-narrow-to-subtree)
    (org-show-todo-tree nil)
    (org-ctrl-c-ctrl-c))

 (defun kahiro-show-NEXT-in-subtree ()
    "Narrow to a subtree and show only headings with TODO keywords"
    (interactive)
    (org-narrow-to-subtree)
    (org-occur (concat "^" org-outline-regexp " *" "\\(NEXT\\|WAITING\\)"))
    (org-ctrl-c-ctrl-c))

 (defun kahiro-show-only-NEXT-in-subtree ()
    "Narrow to a subtree and show only headings with NEXT keyword"
    (interactive)
    (org-narrow-to-subtree)
    (org-show-todo-tree 4)
    (org-ctrl-c-ctrl-c))

 (defun kahiro-show-TODO-in-subtree ()
    "Narrow to a subtree and show only headings with TODO keywords"
    (interactive)
    (org-narrow-to-subtree)
    (org-occur (concat "^" org-outline-regexp " *" "\\(TODO\\|NEXT\\|WAITING\\)"))
    (org-ctrl-c-ctrl-c))

 (defun kahiro-show-PLAN-in-subtree ()
    "Narrow to a subtree and show only headings with TODO keywords"
    (interactive)
    (org-narrow-to-subtree)
    (org-show-todo-tree 13)  ;; Funktion ist abhängig von TODO-Reihenfolge
    (org-ctrl-c-ctrl-c))

 #+END_SRC

 #+RESULTS:
 : kahiro-show-PLAN-in-subtree

**** TODO Erklärung der Synthax
*** Split und Switch
      - Gibt eine Schnelle übersicht in einem halben Fenster. 
 #+BEGIN_SRC emacs-lisp
  (defun kahiro-split-and-switch ()
   "Split the window and switch to the other window in sequence."
   (interactive)
   (split-window-right)
   (org-tree-to-indirect-buffer)
   (other-window 1))
  (global-set-key (kbd "C-c v") 'kahiro-split-and-switch)

 #+END_SRC
*** Switch und Close
      - Kehrt wieder zum Übersichtsbuffer zurück. 
 #+BEGIN_SRC emacs-lisp
  (defun kahiro-switch-and-close ()
   "Split the window and switch to the other window in sequence."
   (interactive)
 ;;  (kill-buffer)
   (delete-window)
 ;;  (other-window -1)
 ;;  (delete-other-windows)
  )

  (global-set-key (kbd "C-c V") 'kahiro-switch-and-close)
 #+END_SRC
*** Fold current tree up to lvl1 heading
    - [[https://christiantietze.de/posts/2019/06/org-fold-heading/][Quelle]] [2021-07-28 Mi]
    #+begin_src emacs-lisp :results output silent
      (defun ct/org-foldup ()
	"Hide the entire subtree from root headline at point."
	(interactive)
	(widen)
	(while (ignore-errors (outline-up-heading 1)))
	(org-flag-subtree t))


      (defun ct/org-ctrltab (&optional arg)
	(interactive "P")
	(if (or (null (org-current-level))     ; point is before 1st heading, or
		(and (= 1 (org-current-level)) ; at level-1 heading, or
		     (org-at-heading-p))
		(org-at-table-p))              ; in a table (to preserve cell movement)
		; perform org-shifttab at root level elements and inside tables
		(org-shifttab arg)
		; try to fold up elsewhere 
		(ct/org-foldup)))
      (org-defkey org-mode-map (kbd "C-<tab>") 'ct/org-ctrltab)
#+end_src
*** Show TODOs in currend lvl 1 heading
    [2021-07-28 Mi]
    #+begin_src emacs-lisp :results output silent
      (defun kahiro/show-todos-lvl1-heading ()
	"Show all the Todos with TODO, NEXT and WAITING"
	(interactive)
	(ct/org-ctrltab)
	(kahiro-show-TODO-in-subtree)
	(widen)
	)      
#+end_src

*** COMMENT Apply :Archive: Tag to DONE Tasks
 #+BEGIN_SRC emacs-lisp
 (setq org-todo-state-tags-triggers
   (quote 
   (("DONE" ("ARCHIVE" . t)) ;; Set ARCHIVE tag when state changes to DONE
    ("" ("ARCHIVE"))         ;; Unset ARCHIVE tag when state changes to "" (no state)
   )))
 #+END_SRC
**** TODO Review
     - aussortiert weil nervig
** [#B] Agenda-Mode
   - [[*for org-agendas][Link zu Keyboard-Shortcuts]]
*** Agenda custom commands :ausgelagert:
 - moved to separate file:
   - Linux [[file:~/org/_config/emacs/customagendas.org::*Custom Agendas][Custom Agendas]]
*** Generelle Agenda Einstellungen
#+begin_src emacs-lisp :results output silent
(setq org-agenda-skip-scheduled-if-done t
      org-agenda-skip-deadline-if-done t
      org-agenda-skip-deadline-prewarning-if-scheduled t
      org-deadline-warning-days 2)

(add-hook 'org-agenda-mode-hook
	  (lambda()
	    (local-set-key (kbd "S-<up>") 'org-agenda-date-earlier-hours)
	    (local-set-key (kbd "S-<down>") 'org-agenda-date-later-hours)
	  )
     )
  ;; Activate plain list cycle
  (setq org-list-use-circular-motion t)
#+END_SRC

**** Default Org-Agenda Span
 #+BEGIN_SRC emacs-lisp
 ;; Default span
 (setq org-agenda-span 2)
 #+END_SRC
**** Zeilen in der Agenda nicht umbrechen
 #+begin_src emacs-lisp
 ;; Kein visual-line-mode in Agendas - Lange Zeilen werden nicht umbebrochen
 (add-hook 'org-agenda-mode-hook
           (lambda ()
             (visual-line-mode -1)
             (toggle-truncate-lines 1)))
 #+end_src
**** Sticky Agenda
     - Agenda wird nicht gekillt, sondern bleibt als Buffer im Hintergrund. 
  #+begin_src emacs-lisp
  (setq org-agenda-sticky t)
  #+end_src
*** Eigene Agenda-Funktionen :defun:
**** Start Agenda with current buffer :Funktionen:
#+begin_src emacs-lisp :results output silent
(defun kahiro-agenda-of-current-buffer (&optional arg)
   (interactive "P")
   (org-agenda arg "a" t))

(defun kahiro-todo-of-current-buffer (&optional arg)
   (interactive "P")
   (org-agenda arg "t" t))
#+end_src
**** beschränkte Agendas :new:
 - [X] alle TODOS aus einem Subtree
 - [X] TODO-Liste für NEXT aus dem Subtree
 - [X] TODO-Liste für Waiting aus dem Buffer/Subtree
 - [X] TODO-Liste für Waiting der Agenda mit Prio A
 - [X] TODO-Liste für Waiting aus dem Subtree
 - [ ] TODO-Liste für Waiting mit xa-Kategorie
 - [ ] DONE-Lise eines Subtrees
 - [ ] TODO-Liste aller Aufgaben eines Buffers/Subtrees mit Prio A
 - [ ] TODO-Liste aller PLAN Aufgaben eines Subtrees
 - [ ] Tasks mit dem Tag Heute
 - [ ] 
#+begin_src emacs-lisp :results output silent
;; alle TODOs eines Subtrees
(defun kahiro-todo-of-current-subtree (&optional arg)
   (interactive "P")
   (org-agenda arg "t" 'subtree))

;; alle NEXT aus dem Subtree
(defun kahiro-NEXT-of-current-buffer (&optional arg)
   (interactive "P")
   (org-agenda arg "?" 'subtree)) ;; edit

;; alle WAITING aus dem Subtree
(defun kahiro-WAITING-of-current-buffer (&optional arg)
   (interactive "P")
   (org-agenda arg "?" 'subtree)) ;; edit

;; alle WAITING aus dem Buffer
(defun kahiro-NEXT-of-current-buffer (&optional arg)
   (interactive "P")
   (org-agenda arg "?" 'buffer)) ;; edit

;; alle WAITING der Agenda-Files mit Prio A aus dem Buffer
(defun kahiro-NEXT-of-current-buffer (&optional arg)
   (interactive "P")
   (org-agenda arg "?" nil)) ;; edit

;; alle WAITING mit Kategorie "xa"
(defun kahiro-WAITING-of-current-buffer (&optional arg)
   (interactive "P")
   (org-agenda arg "?" nil)) ;; edit

#+end_src
*** Calendar-week
    - Zeigt die Kalenderwiche im Kalender an.
 #+begin_src elisp
 (copy-face font-lock-constant-face 'calendar-iso-week-face)
 (set-face-attribute 'calendar-iso-week-face nil
                     :height 0.7)
 (setq calendar-intermonth-text
       '(propertize
         (format "%2d"
                 (car
                  (calendar-iso-from-absolute
                   (calendar-absolute-from-gregorian (list month day year)))))
         'font-lock-face 'calendar-iso-week-face))

 (copy-face 'default 'calendar-iso-week-header-face)
 (set-face-attribute 'calendar-iso-week-header-face nil
                     :height 0.7)
 (setq calendar-intermonth-header
       (propertize "KW"                  ; or e.g. "KW" in Germany
                   'font-lock-face 'calendar-iso-week-header-face))

 (setq calendar-week-start-day 1)
 #+end_src
*** org-Recur :obsolet:package:
    - Paket für die wiederholte Planung von Überchriften
 #+begin_src emacs-lisp :results silent
 (use-package org-recur
   :hook ((org-mode . org-recur-mode)
          (org-agenda-mode . org-recur-agenda-mode))
   :demand t
   :bind (:map org-recur-agenda-mode-map
           ("d" . org-recur-finish)
	   ("C-c d" . org-recur-finish)
	   :map org-recur-mode-map
	    ("C-c d" . org-recur-finish))
 ;;  :config
 ;;  (define-key org-recur-mode-map (kbd "C-c d") 'org-recur-finish)

   ;; Rebind the 'd' key in org-agenda (default: `org-agenda-day-view').
   ;;  (define-key org-recur-agenda-mode-map (kbd "d") 'org-recur-finish)
   ;;  (define-key org-recur-agenda-mode-map (kbd "C-c d") 'org-recur-finish)
 )
 #+end_src
*** org-habit :package:local:
 Mit org-habit kann man regelmäßige Aufgaben verfolgen, etwa den Müll rausbringen, oder Sport treiben. Man kann es so einstellen, dass die Aufgabe nur alle x Tage auftaucht. 
 #+BEGIN_SRC emacs-lisp
 ;; Den Habit-Graph auf Position (von links) bringen.
 (setq org-habit-graph-column 50)
 #+END_SRC
*** Clockcheck
org-agenda-clock-consistency-checks’s value is
#+begin_src emacs-lisp :results output silent
(setq org-agenda-clock-consistency-checks
      '(:max-duration "10:00" :min-duration 0 :max-gap "0:01" :gap-ok-around
		      ("4:00" "13:00")
		      :default-face
		      ((:background "DarkRed")
		       (:foreground "white"))
		      :overlap-face nil :gap-face nil :no-end-time-face nil :long-face nil :short-face nil))
#+end_src

**** from the Org-Manual:
This is a property list, with the following keys:

#+begin_example
:max-duration    Mark clocking chunks that are longer than this time.
                 This is a time string like "HH:MM", or the number
                 of minutes as an integer.

:min-duration    Mark clocking chunks that are shorter that this.
                 This is a time string like "HH:MM", or the number
                 of minutes as an integer.

:max-gap         Mark gaps between clocking chunks that are longer than
                 this duration.  A number of minutes, or a string
                 like "HH:MM".

:gap-ok-around   List of times during the day which are usually not working
                 times.  When a gap is detected, but the gap contains any
                 of these times, the gap is *not* reported.  For example,
                 if this is ("4:00" "13:00") then gaps that contain
                 4:00 in the morning (i.e. the night) and 13:00
                 (i.e. a typical lunch time) do not cause a warning.
                 You should have at least one time during the night in this
                 list, or otherwise the first task each morning will trigger
                 a warning because it follows a long gap.
#+end_example

Furthermore, the following properties can be used to define faces for
issue display.

:default-face         the default face, if the specific face is undefined
:overlap-face         face for overlapping clocks
:gap-face             face for gaps between clocks
:no-end-time-face     face for incomplete clocks
:long-face            face for clock intervals that are too long
:short-face           face for clock intervals that are too short

  This variable was introduced, or its default value was changed, in
  version 24.1 of Emacs.
  You can customize this variable.

** org-capture templates :ausgelagert:
 - moved to separate file:
   - Windows: [[file:c:/org/_config/emacs/capture.org::*Code][Code]]
   - Linux: [[file:~/org/_config/emacs/capture.org::*Code][Code]]
** Projektmanagement
*** recursive statistic cookie for PROJ status
#+begin_src emacs-lisp :results output silent
(defun kahiro/org-recursive-statistics-for-proj ()
  (interactive)
  (when (equal (org-get-todo-state) "PROJ")
    (org-set-property "COOKIE_DATA" "todo recursive"))
  (when (equal (org-get-todo-state) "TODO")
    (org-delete-property "COOKIE_DATA"))
)

(add-hook 'org-after-todo-state-change-hook 'kahiro/org-recursive-statistics-for-proj)
#+end_src

** Allgemein
*** Archiv-Location
  - Link zur Hilfe: [[help:org-archive-location]]
**** Beispiele
     - in der config: (setq org-archive-location "datei::** unterDieserHeadingSortieren")
     - in der datei: #+ARCHIVE: datei::** unterDieserHeadingSortieren
       oder: #+ARCHIVE: %s_archive::datetree/
     - in der subheading
       :PROPERTIES:
       :ARCHIVE: datei::** unterdieserheadingsortieren
       :END:

 Here are a few examples:
 "%s_archive::"
	 If the current file is Projects.org, archive in file
	 Projects.org_archive, as top-level trees.  This is the default.

 "::* Archived Tasks"
	 Archive in the current file, under the top-level headline
	 "* Archived Tasks".

 "~/org/archive.org::"
	 Archive in file ~/org/archive.org (absolute path), as top-level trees.

 "~/org/archive.org::* From %s"
	 Archive in file ~/org/archive.org (absolute path), under headlines
         "From FILENAME" where file name is the current file name.

 "~/org/datetree.org::datetree/* Finished Tasks"
         The "datetree/" string is special, signifying to archive
         items to the datetree.  Items are placed in either the CLOSED
         date of the item, or the current date if there is no CLOSED date.
         The heading will be a subentry to the current date.  There doesn’t
         need to be a heading, but there always needs to be a slash after
         datetree.  For example, to store archived items directly in the
         datetree, use "~/org/datetree.org::datetree/".

 "basement::** Finished Tasks"
	 Archive in file ./basement (relative path), as level 3 trees
	 below the level 2 heading "** Finished Tasks".

 You may set this option on a per-file basis by adding to the buffer a
 line like

 #+ARCHIVE: %s_archive::datetree

 You may also define it locally for a subtree by setting an ARCHIVE property
 in the entry.  If such a property is found in an entry, or anywhere up
 the hierarchy, it will be used.
*** Dateiendungen
 #+BEGIN_SRC emacs-lisp :results output silent
  (add-to-list 'auto-mode-alist '("\\.org$" . org-mode))
  (add-to-list 'auto-mode-alist '("\\.org_archive\\'" . org-mode))
 ;; (add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode))
  #+END_SRC
*** org-goto :navigation:
 #+begin_src emacs-lisp :results output silent
 (setq org-goto-interface 'outline-path-completion) ;; alternative 'outline
 (setq org-outline-path-complete-in-steps nil)
 #+end_src
 [[https://emacs.stackexchange.com/questions/32617/how-to-jump-directly-to-an-org-headline][Link:]] Setting org-goto-interface to one of the two recognised values does not mean sacrificing the alternative interface. Calling org-goto with a prefix argument (i.e. C-u C-c C-j or C-u M-x org-goto RET) automatically selects the alternative interface for the current completion. This way, you can set org-goto-interface to the interface you are likely to use most often and use the prefix argument when you wish to temporarily switch behaviour. If even this does not suit your needs, you can always write your own wrapper around org-goto, as per Att Righ's example.
*** refile" targets :Funktionen:
 #+BEGIN_SRC emacs-lisp :results output silent
 ;; setting Refile Target
 (setq org-refile-targets `(
   (org-agenda-files :maxlevel . 1)       ;; Für Agenda-Dateien normalerweise nur in * Überschriften
   (,(concat org-directory "/atasks.org") :maxlevel . 2)  ;; Für atask.org auch in ** Überschriften
   (,(concat org-directory "/br/br.org") :maxlevel . 2)
))

 ;; TODO Hier fehlt noch eine Erklärung
 (setq org-refile-allow-creating-parent-nodes 'confirm)     ;;allow creating nodes. Refile has to end with /newheadingname
 (setq org-refile-use-outline-path 'file)

 ;; refile nur in der aktuellen Datei (geklaut von Sacha Chua). Aufruf über c-W.
 (defun my/org-refile-in-file (&optional prefix)
   "Refile to a target within the current file."
   (interactive)
   (let ((org-refile-targets `(((,(buffer-file-name)) :maxlevel . 3))))   ;; Für aktuelle Datei bis in *** Überschriften.
     (call-interactively 'org-refile)))
 #+END_SRC
**** COMMENT Option: Refile in alle geöffneten Buffer
     - geklaut von hier :: https://emacs.stackexchange.com/questions/22128/how-to-org-refile-to-a-target-within-the-current-file
 #+begin_src emacs-lisp :results output silent
 (defun my-org-files-list ()
   (delq nil
     (mapcar (lambda (buffer)
       (buffer-file-name buffer))
       (org-buffer-list 'files t))))

 (setq org-refile-targets '((my-org-files-list :maxlevel . 1)))
 #+end_src
**** Inspirationsquellen
     - quasiquote für funktionen in einer liste, wie concat oder buffer-file-name :: [[https://lists.gnu.org/archive/html/emacs-orgmode/2012-07/msg00561.html][Link]] and [[https://www.gnu.org/software/emacs/manual/html_node/elisp/Backquote.html][elisp-Manual]]. 
** LateX
- gesamte Variable:   (setq org-format-latex-options '(:foreground default :background default :scale 1.0 :html-foreground "Black" :html-background "Transparent" :html-scale 1.0 :matchers
	     ("begin" "$1" "$" "$$" "\\(" "\\[")))
- aber eigentlich reicht es nur einen Wert zu vernändern:
#+begin_src emacs-lisp :results output silent
(setq org-format-latex-options (plist-put org-format-latex-options :scale 2.0))
#+end_src
** Export nach odt bzw. docx :WindowsOnly:
#+begin_src emacs-lisp :results output silent
(when (string-equal system-type "windows-nt")

  (setq org-odt-preferred-output-format "docx")

  (defun config-org-export-as-docx-via-odt ()
    (interactive)
    (let ((cmd "C:\\Software\\LibreOffice\\App\\libreoffice\\program\\soffice.exe"))
      (when (and (eq system-type 'windows-nt) (file-exists-p cmd))
        ;; org v8/v9
        (setq org-odt-convert-processes '(("LibreOffice" "C:\\Software\\LibreOffice\\App\\libreoffice\\program\\soffice.exe --headless --convert-to %f%x --outdir %d %i"))))
    ))

  (config-org-export-as-docx-via-odt)
)
 
#+end_src
** Clocking / Aufwand
 - [[info:org#Resolving idle time][Info-Document for org#Resolving idle time]]
#+begin_src emacs-lisp :results output silent
;; CLOCKING: global Effort estimate values
(setq org-global-properties
      '(("Effort_ALL" .
         "1:00 2:00 3:00 4:00 5:00 0:10 0:20 0:30 0:45 0:00 6:00 7:20 8:00 9:00 10:00")))
;;        1    2    3    4    5    6    7    8    9    0
;; These are the hotkeys

;; CLOCKING: Set default column view headings: Task Priority Effort Clock_Summary
(setq org-columns-default-format "%45ITEM(Beschreibung) %2PRIORITY %5Effort(Effrt){:} %5CLOCKSUM_T(Today) %7TODO %14SCHEDULED")

;; Set default format in Agenda to global default format
(setq org-columns-default-format-for-agenta org-columns-default-format)
;; Clocking
;;---------
(setq org-clock-persist 'history)
(org-clock-persistence-insinuate) ;; Info: Runs hooks for clocking persistance.
(setq org-clock-idle-time 15) ;; Nach 15 Minuten Idle, kommt die Frage, ob die Zeit anders zugeteilt werden soll (resolving idle time)
#+end_src
*** TODO [#C] Erklärung für org-clock-persistence-insinuate
*** Clock-Report bis auf 3 Level tief
#+begin_src emacs-lisp
;; Clock-Report-View auf Level 3
(setq org-agenda-clockreport-parameter-plist '(:link t :maxlevel 3))
#+end_src
** Make org beautiful
*** hide emphasis markers
#+BEGIN_SRC emacs-lisp
;; Make Org beautiful
;;-------------------
(setq org-hide-emphasis-markers t) ;; hide Markers like *this* for bold
#+END_SRC
*** Use Org-Bullets :package:appearance:
    Schönere Auflist-Zeichen (in UTF8) für Org-Überschriften
   #+BEGIN_SRC emacs-lisp
(use-package org-bullets
  :after org
  :hook (org-mode . org-bullets-mode)
)
  (when (string-equal system-type "windows-nt")
   (setq org-bullets-bullet-list '("✥" "✤" "❖" "✿" "❄" "❋" "★" "✚")) ;; "✠" "✚" "✜" "✛" "✢" "✣" "✤" "✥"
  )
  (when (string-equal system-type "gnu/linux")
    (setq org-bullets-bullet-list '("⚜" "⚙" "❖" "✿" "❄" "❋" "★" "⚛")) ;; "✠" "✚" "✜" "✛" "✢" "✣" "✤" "✥"
  )
  #+END_SRC

*** Set custom ellipsis (...)
  #+BEGIN_SRC emacs-lisp
  (setq org-ellipsis "⤵")
   #+END_SRC
** FEHLER org-caldav :WindowsOnly:Paket:
Compiling internal form(s) at Wed Mar  3 23:13:32 2021
Warning (bytecomp): reference to free variable ‘org-icalendar-timezone’
Warning (bytecomp): reference to free variable ‘org-export-before-parsing-hook’
Warning (bytecomp): reference to free variable ‘org-icalendar-timezone’
Warning (bytecomp): ‘org-set-tags-to’ is an obsolete function (as of Org 9.2); use ‘org-set-tags’ instead.
Warning (bytecomp): the following functions are not known to be defined:
oauth2-auth-and-store, oauth2-url-retrieve-synchronously

#+begin_src emacs-lisp :results silent
(when (string-equal system-type "windows-nt")
    (use-package org-caldav
      :init
      (setq org-caldav-url "https://cloud.ist.gold/remote.php/dav/calendars/fabian")
      (setq org-caldav-calendars
      `((:calendar-id "org"
         :inbox ,(concat org-directory "/calinbox.org")
         :files (,(concat org-directory "/calendar.org"))
         :skip-conditions ('todo 'done)
      )))
      (setq org-icalendar-timezone "Europe/Berlin")
      (setq org-caldav-backup-file (concat org-directory "/caldav/org-caldav-backup.org"))
      (setq org-caldav-save-directory (concat org-directory "/caldav/"))


      :config
      ;; This enables alarms in entries on export
      (setq org-icalendar-alarm-time 1)
      ;; This makes sure to-do items as a category can show up on the calendar
      (setq org-icalendar-include-todo t)
      ;; This ensures all org "deadlines" show up, and show up as due dates
      (setq org-icalendar-use-deadline '(event-if-todo-not-done event-if-not-todo todo-due))
      ;; This ensures "scheduled" org items show up, and show up as start times
      (setq org-icalendar-use-scheduled '(todo-start event-if-todo event-if-not-todo))
     )
)
#+end_src
** FEHLER org-table                                      :Funktionen:
[2021-07-28 Mi]- Probleme beim Laden
   #+begin_src emacs-lisp :results output silent
(defun calcFunc-dateDiffToHMS (date1 date2 worktime-per-day)
  "Calculate the difference of DATE1 and DATE2 in HMS form.
Each day counts with WORKTIME-PER-DAY hours."
  (cl-labels ((dateTrunc (date)
             (calcFunc-date (calcFunc-year date)
                    (calcFunc-month date)
                    (calcFunc-day date)))
          (datep (date)
             (and (listp date)
              (eq (car date) 'date))))
    (if (and (datep date1)
         (datep date2))
    (let* ((business-days (calcFunc-bsub
                   (dateTrunc date1)
                   (dateTrunc date2))))
      (calcFunc-add
       (calcFunc-hms (calcFunc-mul business-days worktime-per-day) 0 0)
       (calcFunc-sub (calcFunc-time date1) (calcFunc-time date2)))
      )
      0)))   
#+end_src
** structure template (code)
#+begin_src emacs-lisp :results output silent
(setq org-structure-template-alist
  '(("s" . "src")
    ("sc" . "src conf")
    ("se" . "src emacs-lisp")
    ("sj" . "src javascript")
    ("sv" . "src java")
    ("svt" . "src java :noweb yes")
    ("svn" . "src java :tangle no")
    ("sp" . "src python :results output")
;;    ("spt" . "src python :noweb yes")
;;    ("spn" . "src python :tangle no")
    ("sr" . "src R")
    ("ss" . "src emacs-lisp :results output silent")
    ("sh" . "src shell")
;;    ("h" . "export html")
;;    ("l" . "export latex")
;;    ("q" . "quote")
;;    ("c" . "comment")
    ))
#+end_src
*** OK [#B] Org Tempo oder yasnippet einrichten
*** Info zu Source Blocks
 They changed the template system in orgmode 9.2.

 The new mechanism is called structured template. The command org-insert-structure-template bound to *C-c C-,* gives you a list of #+begin_-#+end_ pairs that narrows down while you type and you can use completion.

 But, you can also get the old easy template system back, either

     by adding (require 'org-tempo) to your init file or
     by adding org-tempo to the list org-modules. You can do that by customizing org-modules.

** Tag-Vererbung
#+begin_src emacs-lisp :results output silent
(setq org-tags-exclude-from-inheritance '("Autor" "Fokus" "TB" "leer" "kur" "gut" "2022" "Reportage" "Portrait" "ContentLeitstand" "CL"))
;;(setq org-use-tag-inheritance nil)
#+end_src

** Todos
*** Konzept
 - _Projektarbeit_: Die Todos sind zu jedem Ende der Sequenz nach Wichtigkeit sortiert. =HELP= ist das wichtigste/dringendste Projekt-Keyword und =NEXT=  das wichtiste TODO-Keyword.
   - HELP: Aufgaben, wo ich Unterstützung brauche, und allein nicht weiterkomme.
   - DECIS: Ich/Wir müssen eine Entscheidung treffen, bevor es weiter gehen kann
   - DELEG: Das Abgeben an andere, die die Aufgabe besser erledigen können
   - SPLIT: Teile eine Aufgabe, die zu groß ist in kleinere Schritte auf; eine gute Gelegenheit sich den Ablauf nochmal konkret bewusst zu machen.
   - PROJ: Todos mit mehren Teilschritten; ein Ziel zu notieren hilft bei der späteren Bewertung, ob es weiter verfolgt werden soll.
   - MEET: Terminierte Treffen mit anderen Leuten
   - PLAN: Dinge, die optional erledigt werden sollen
   - WAITING: Aufgabe benötigt  Input von anderen Personen, bevor sie weiter bearbeitet werden kann.
   - DATE: Angedachte Treffen für die noch ein Termin gefunden werden soll.
   - TODO: Aufgaben, die abgearbeitet werden sollen.
   - NEXT: Wichtige Aufgabe, die erledigt wird, sobald Zeit ist.
*** Todo-Status und -Sequenzen
Options: 
 - ! :: Timestamp
 - @ :: Note with timestamp
 - / :: trigger when leaving the state
 #+begin_src emacs-lisp :results output silent
 (setq org-todo-keywords
   '(
     ;; Textarbeit
     (sequence "IDEE(i!)" "SUCHE(f!)" "ANGEB(a!)" "BAUFT(b!)" "VORH(v!)" "|" "CANC(c)")
     ;; Projetarbeit
     (sequence "HELP(h@)" "DECIS(e!/@)" "DELEG(l@)" "SPLIT(s)" "PROJ(j!)" "MEET(m)"  "PLAN(p)" "WAITING(w!/!)" "DATE(x)" "TODO(t)" "NEXT(n)" "|" "DONE(d)")
    )) 
 #+end_src
  es ginge auch nur:  (sequence "|"  "CANC(c)")
*** Todo Cookie recursiv
- deaktivert [2021-08-05 Do], weil besser nur dann gesetzt, wenn TODO=PROJ
#+begin_src emacs-lisp :results output silent
;;(setq org-hierarchical-todo-statistics nil)
#+end_src
** Textbearbeitung
*** TODO [#D] COMMENT unfill paragraph :Funktionen:deaktiviert:
 #+BEGIN_SRC emacs-lisp
 ;;; Stefan Monnier <foo at acm.org>. It is the opposite of fill-paragraph    
 (defun unfill-paragraph (&optional region)
   "Takes a multi-line paragraph and makes it into a single line of text."
   (interactive (progn (barf-if-buffer-read-only) '(t)))
   (let ((fill-column (point-max))
	 ;; This would override `fill-column' if it's an integer.
	 (emacs-lisp-docstring-fill-column t))
     (fill-paragraph nil region)))

 ;; Handy key definition
 (define-key global-map "\M-Q" 'unfill-paragraph)
 #+END_SRC
** org-babel
Enable python and shell as languages for org babel.
#+begin_src emacs-lisp :results output silent
(org-babel-do-load-languages
 'org-babel-load-languages '(
			     (shell . t)
			     (python . t))
 )
#+end_src
** COMMENT local setup on linux
Außerdem habe ich /usr/bin/python auf python3 symbolisch verlinkt mit
#+begin_src shell
cd /usr/bin
ln -s ./python3 /python
#+end_src
so dass jeder Aufruf von "python" jetzt "python3" startet. _Dieser Schritt muss für jedes Linux-System ggf. neu ausgeführt werden._


* Custom Functions

** clone-rename-narrow
#+begin_src emacs-lisp :results output silent
(defun kahrio/clone-rename-narrow (&optional arg)   
 (interactive "P")
 (clone-indirect-buffer (nth 4 (org-heading-components)) t nil)
 (org-narrow-to-subtree)
)
#+end_src

** done and next
#+begin_src emacs-lisp :results output silent
(defun kahiro-done-and-next  (&optional arg)
  (interactive "P")
  (org-todo "DONE")
  (org-forward-heading-same-level 1 nil)
  (recenter-top-bottom 5)
)
#+end_src
** mark region or subtree DONE
#+begin_src emacs-lisp :results output silent
(defun org-todo-region ()
  (interactive)
  (let ((scope (if mark-active 'region 'tree))
        (state (org-fast-todo-selection))
        (org-enforce-todo-dependencies nil))
    (org-map-entries (lambda () (org-todo state)) nil scope)))
#+end_src

** Next und Clock in :neu:
#+begin_src emacs-lisp :results output silent
(defun kahiro-next-and-clock-in  (&optional arg)
  (interactive "P")
  (org-todo "NEXT")
  (org-clock-in)
)
#+end_src
** TODO Sorting
   - Weil ich häufig sortiere, lege ich eigene Funktionen auf die häufigsten Sortier-Befehle
#+begin_src emacs-lisp :results output silent
(defun kahiro-sort-by-time-reverse (&optional arg)
 (interactive)
 (org-sort-entries nil ?T)
)

(defun kahiro-sort-by-time (&optional arg)
 (interactive)
 (org-sort-entries nil ?t)
)


(defun kahiro-sort-by-priority (&optional arg)
 (interactive)
 (org-sort-entries nil ?p)
)

(defun kahiro-sort-by-todo (&optional arg)
 (interactive)
 (org-sort-entries nil ?o)
)

(defun kahiro-sort-by-todo-reverse (&optional arg)
 (interactive)
 (org-sort-entries nil ?O)
)

#+end_src
** FEHLER COMMENT Count Tags :defun:
   - [2020-04-19 Sun] ggf. gibt es einen Konflikt mit [[*Style Tags based on Regular Expressions][Style Tags based on Regular Expressions]]
#+begin_src emacs-lisp :results output silent
(defun count-tags ()
  (let (tags count)
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward org-complex-heading-regexp nil t)
        (dolist (tag (org-get-tags))
          (push tag tags)))
      (cl-loop with result
               for tag in tags
               do (push (list (cl-count tag tags
                                        :test #'string=)
                              tag)
                        count)
               collect
               (setq result (cl-remove-duplicates count
                                                  :test #'equal))
               finally return
               (cl-sort result #'> :key #'car)))))

:colnames '(freq tags)
(count-tags)
#+end_src
** Clone buffer rename
#+begin_src emacs-lisp :results output silent
  (defun kahiro-clone-rename-narrow (&optional arg)
   (interactive "P")
   (clone-indirect-buffer 
     (replace-regexp-in-string
     " \\[[[:digit:]]*[/%][[:digit:]]*\\]" "" 
     (nth 4 (org-heading-components)))
     t nil)
   (org-narrow-to-subtree)
  )

#+end_src

* Keys / Tastenkürzel
** Allgemein
#+begin_src emacs-lisp :results output silent
;; use ibuffer as default
(global-set-key (kbd "C-x C-b") 'ibuffer)
(global-set-key (kbd "C-x c") 'kahiro-clone-rename-narrow)
#+end_src

** Fokus
#+begin_src emacs-lisp :results output silent

#+end_src
**  Jump in the doc1ument
   "Move cursor to last mark position of current buffer.
   Call this repeatedly will cycle all positions in `mark-ring'.
   URL `http://ergoemacs.org/emacs/emacs_jump_to_previous_position.html'
   Version 2016-04-04"
 #+BEGIN_SRC emacs-lisp
   (defun xah-pop-local-mark-ring ()
     (interactive)
     (set-mark-command t))
   (global-set-key (kbd "<S-f3>") 'pop-global-mark)
   (global-set-key (kbd "<s-f3>") 'xah-pop-local-mark-ring) 
 #+END_SRC 
** RYO Key settings
*** TODOs
**** TODO ryo-modal-keys snippet um ryo keys testen zu können. 
 (ryo-modal-keys 
...
)
**** DONE Sortierfunktionen auf eine eigene Taste legen.

*** Tastenfunktionen
#+BEGIN_SRC emacs-lisp
(defun org-timer-start-with-offset ()
  "Start the timer and prompt user to enter a time offset"
    (interactive)
    (org-timer-start '(4)))
#+END_SRC
*** Colors
#+BEGIN_SRC emacs-lisp
(setq ryo-modal-cursor-color "maroon")
(setq ryo-modal-default-cursor-color "sea green")
#+END_SRC

#+RESULTS:
: sea green

*** Basics
    + [2020-05-12 Di 13:36] Zahlen ausgeklammert, da ich sie kaum als Prefix brauche.
 #+BEGIN_SRC emacs-lisp
     (use-package ryo-modal
       :commands ryo-modal-mode
       :bind ("S-SPC" . ryo-modal-mode)
       :bind ("µ" . ryo-modal-mode)
       :config
       (ryo-modal-keys
	("," ryo-modal-repeat)
	("q" ryo-modal-mode))
	
       (ryo-modal-keys
	;; First argument to ryo-modal-keys may be a list of keywords.
	;; These keywords will be applied to all keybindings.
	(:norepeat t)
        ("u" universal-argument)
	("h" backward-char)
	("j" next-line)
	("k" previous-line)
	("l" forward-char)
	("e" "C-e")
	("a" "C-a")
	("I" "M-a")
	("O" "M-e")
	("A" "M-<")
	("E" "M->")
;;	("0" "M-0")
;;	("1" "M-1")
;;	("2" "M-2")
;;	("3" "M-3")
;;	("4" "M-4")
;;	("5" "M-5")
;;	("6" "M-6")
;;	("7" "M-7")
;;	("8" "M-8")
;;	("9" "M-9")
)

   )
 #+End_SRC

*** Multiple Keys
    Hier werden Befehle mit mehr als einem Tastenkürzel ausgeführt. Der erste Buchstabe ist also ein Prefix, auf den noch mindestens ein weiterer folgt.
**** Start
#+BEGIN_SRC emacs-lisp :results silent
; (require 'org-timer)
 (ryo-modal-keys 
#+end_src

**** b
#+begin_src emacs-lisp
    ("b"
     (("b" bookmark-jump :first (org-mark-ring-push)) ;; 
      ("i" bookmark-jump :first (org-mark-ring-push) :then (org-clock-in))
      ("j" imenu-anywhere)
      ("m" bookmark-set)
      ("l" bookmark-bmenu-list)
      ("s" bookmark-save)
      ("o" bookmark-jump-other-window)
      ("v" org-mark-ring-push)
      ("n" org-mark-ring-goto)
     ))
#+end_src

**** c
#+begin_src emacs-lisp
    ("c"
    (("c" org-ctrl-c-ctrl-c) ;; getauscht mit c C weil häufiger genutzt 
     ("a" org-attach)
     ("b" org-backward-heading-same-level)
     ("C" org-capture)       ;; getauscht mit c c
     ("n" org-capture)     
     ("d" org-deadline)
     ("e" org-export-dispatch)
     ("f" org-forward-heading-same-level)
     ("j" org-goto)
     ("k" org-kill-note-or-show-branches)
     ("l" org-store-link)
     ("L" org-insert-link)
     ("o" org-open-at-point)
     ("q" org-set-tags-command)
     ("r" org-reveal)
     ("s" org-schedule)
     ("t" org-todo)
     ("w" org-refile)
     ("W" my/org-refile-in-file)
     ("*" org-list-make-subtree)
;     ("TAB" org-ctrl-c-tab)  ;; für raspi deaktiviert
     ("RET" org-ctrl-c-ret)
     ("y" org-evaluate-time-range)
     ("z" org-add-note)
     ("^" org-up-element)
     ("_" org-down-element)
     ("SPC" org-table-blank-field)
     ("!" org-time-stamp-inactive)
     ("#" org-insert-structure-template)
     ("%" org-mark-ring-push)
     ("&" org-mark-ring-goto)
     ("'" org-edit-special)
     ("*" org-ctrl-c-star)
     ("+" org-table-sum)
     ("," org-priority)
     ("-" org-ctrl-c-minus)
     ("." org-time-stamp)
     ("/" org-sparse-tree)
     (":" org-toggle-fixed-width)
     (";" org-toggle-comment)
     ("<" org-date-from-calendar)
     ("=" org-table-eval-formula)
     (">" org-goto-calendar)  
     ("?" org-table-field-info)
     ("@" org-mark-subtree)
     ("\[" org-agenda-file-to-front)
     ("\\" org-match-sparse-tree)
     ("\]" org-remove-file)
     ("^" org-sort)
     ("v" org-sort)
     ("`" org-table-edit-field)
     ("{" org-table-toggle-formula-debugger)
     ("|" org-table-create-or-convert-from-region)
     ("}" org-table-toggle-coordinate-overlays)
     ("~" org-table-create-with-table.el)
     ("x"
       (("a" org-archive-subtree-default)
        ("e" org-clock-modify-effort-estimate) ;; neu [2021-02-15 Mo]
        ("c" org-columns) ;; :then (recenter-top-bottom 3)) 
      ))
     ))
#+end_src
**** f
#+begin_src emacs-lisp
  ("f"
   (("e" org-emphasize)
    ("j" ess/org-show-just-me)
    ("f" ess/org-show-just-me)
    ("u" unfill-paragraph)
    ("U" unfill-toggle)
   ))
#+end_src

**** TODO g
 - add xa function:
clone-indirect-buffer-other-window
rename-buffer xa
org-narrow-to-subtree
#+begin_src emacs-lisp
    ("g"
     (("a" org-agenda)
      ("b" split-window-below)     ;; r for split-window-right
      ("c" kahiro-switch-and-close)
      ("D" delete-frame)
      ("d" delete-window)
      ("f" delete-other-windows)
      ("g" switch-to-buffer)
      ("h" org-backward-heading-same-level)
      ("n" org-next-visible-heading)
      ("p" org-previous-visible-heading)
      ("l" org-forward-heading-same-level)
      ("j" org-goto)
      ("2" clone-indirect-buffer-other-window)
      ("N" make-frame-command)
      ("o" other-window)
      ("m" xah-pop-local-mark-ring)
      ("M" pop-global-mark)
      ("r" split-window-right)      ;; b for split-window-below
      ("s" kahiro-split-and-switch)
;      ("S" kahiro-vsplit-and-switch)
      ("t" org-sparse-tree)
      ("u" outline-up-heading)
     ))
#+end_src

**** n
     - hier kommt alles rein, was mit Fokussierung und Ansichten zu tun hat.
#+begin_src emacs-lisp :results output silent
    ("n" 
     (("s" org-narrow-to-subtree)
      ("w" widen)
      ("t" kahiro-show-TODO-in-subtree)
      ("a" kahiro-show-todos-in-subtree) 
      ("n" kahiro-show-NEXT-in-subtree) 
      ("N" kahiro-show-only-NEXT-in-subtree)
      ("j" ess/org-show-just-me)
      ("p" kahiro-show-PLAN-in-subtree)
      ("v" org-agenda-set-restriction-lock)
      ("x" org-agenda-remove-restriction-lock)
      ))
#+end_src

**** m
#+begin_src emacs-lisp :results output silent
    ("m" my/org-remark-prefix)
#+end_src

***** archived anki-editor keys
     (("a" ;anki-editor-commands
      (("n" anki-editor-insert-note)
       ("x" anki-editor-mode)
       ("u" anki-editor-anki-connect-upgrade)
       ("p" anki-editor-push-notes) ;; mit Prefix für "tree", doppel Prefix für "file"
       ("P" anki-editor-retry-failure-notes)
       ("c" anki-editor-cloze-dwim)
       ("C" anki-editor-cloze-region)
       ("h" anki-editor-export-subtree-to-html)
       ("H" anki-editor-convert-region-to-html))
      ))


**** r
#+begin_src emacs-lisp
    ("r"
     (
     ("SPC" org-self-insert-command)
     ("a" org-self-insert-command)
     ("b" org-self-insert-command)
     ("c" org-self-insert-command)
     ("d" org-self-insert-command)
     ("e" org-self-insert-command)
     ("f" org-self-insert-command)
     ("g" org-self-insert-command)
     ("h" org-self-insert-command)
     ("i" org-self-insert-command)
     ("j" org-self-insert-command)
     ("k" org-self-insert-command)
     ("l" org-self-insert-command)
     ("m" org-self-insert-command)
     ("n" org-self-insert-command)
     ("o" org-self-insert-command)
     ("p" org-self-insert-command)
     ("q" org-self-insert-command)
     ("r" org-self-insert-command)
     ("s" org-self-insert-command)
     ("t" org-self-insert-command)
     ("u" org-self-insert-command)
     ("v" org-self-insert-command)
     ("w" org-self-insert-command)
     ("x" org-self-insert-command)
     ("y" org-self-insert-command)
     ("z" org-self-insert-command)
     ("A" org-self-insert-command)
     ("B" org-self-insert-command)
     ("C" org-self-insert-command)
     ("D" org-self-insert-command)
     ("E" org-self-insert-command)
     ("F" org-self-insert-command)
     ("G" org-self-insert-command)
     ("H" org-self-insert-command)
     ("I" org-self-insert-command)
     ("J" org-self-insert-command)
     ("K" org-self-insert-command)
     ("L" org-self-insert-command)
     ("M" org-self-insert-command)
     ("N" org-self-insert-command)
     ("O" org-self-insert-command)
     ("P" org-self-insert-command)
     ("Q" org-self-insert-command)
     ("R" org-self-insert-command)
     ("S" org-self-insert-command)
     ("T" org-self-insert-command)
     ("U" org-self-insert-command)
     ("V" org-self-insert-command)
     ("W" org-self-insert-command)
     ("X" org-self-insert-command)
     ("Y" org-self-insert-command)
     ("Z" org-self-insert-command)
     ("Ü" org-self-insert-command)
     ("Ä" org-self-insert-command)
     ("Ö" org-self-insert-command)
     ("ß" org-self-insert-command)
     ("ü" org-self-insert-command)
     ("ä" org-self-insert-command)
     ("ö" org-self-insert-command)
     (";" org-self-insert-command)
     ("," org-self-insert-command)
     (":" org-self-insert-command)
     ("." org-self-insert-command)
     ))
#+end_src
**** s
#+begin_src emacs-lisp  
    ("s" (
     ("p" kahiro-sort-by-priority)
     ("t" kahiro-sort-by-time-reverse)
     ("T" kahiro-sort-by-time)
     ("o" kahiro-sort-by-todo)
     ("n" kahiro-sort-by-todo-reverse)
     ("s" isearch-forward)
     ("r" isearch-backward)
     ))
#+end_src

**** x
#+begin_src emacs-lisp
    ("x"
     (("a" org-archive-subtree-default)
      ("b" switch-to-buffer)
      ("c" save-buffers-kill-terminal)
      ("d" dired)
      ("f" find-file)
      ("k" kill-buffer)
      ("+" text-scale-adjust)
      ("-" text-scale-adjust)
      ("s" save-some-buffers)
     ))
#+end_src

**** z
#+begin_src emacs-lisp
    ("z"
     (("i" org-clock-in)
      ("o" org-clock-out)
      ("j" org-clock-goto :first (org-mark-ring-push))
      ("x" org-clock-in-last)
      ("q" org-clock-cancel)
      ("d" org-clock-display)
      ("f" kahiro-next-and-clock-in)
      ("," org-timer-pause-or-continue)
      ("-" org-timer-item :exit t)
      ("h" org-timer-item :exit t)
      ("n" org-timer-start)
      ("N" org-timer-start-with-offset)
      ("c" org-timer-set-timer)
      ("." org-timer :exit t)
      ("z" org-time-stamp :exit t)
      ("Z" org-time-stamp)
      ("t" org-time-stamp-inactive :exit t)
      ("T" org-time-stamp-inactive)
      ("s" org-toggle-timestamp-type)
     ))
#+end_src

**** End
#+begin_src emacs-lisp
   )
   

(define-key universal-argument-map (kbd "u") 'universal-argument-more)
#+END_SRC

*** Single Binds
    Hier wird nur ein Key einem anderen zugewiesen oder einer Funktion. Das heißt alle Befehle werden mit nur einem Tastendruck ausgeführt.
#+BEGIN_SRC emacs-lisp :results output silent
  (ryo-modal-keys
    ("ä" org-mark-subtree :then '(next-line count-words))
    ("d" "C-k")
    ("C" org-ctrl-c-ctrl-c)
    ("H" org-metaleft)    
    ("J" org-metadown)    
    ("K" org-metaup)
    ("L" org-metaright)
    ("t" org-todo)
    ("T" org-todo-region) ;; set all todos of region or subtree to STATE
    ("N" kahiro-done-and-next) ;; set current todo DONE and go to next of same level
;;    ("R" rename-buffer)
;;    ("R" flyspell-check-previous-highlighted-word)
    ("ü" kahiro/show-todos-lvl1-heading)
    ("_" "C-_")
    ("y" "C-y")
    ("w" "M-w")
    ("W" "C-w")
    ("v" "C-v") 
    ("V" "M-v")
    ("i" "M-b")
    ("o" "M-f")
    ("SPC" org-cycle)
    ("ö" set-mark-command)
    (";" org-toggle-comment)
  )
    #+END_SRC

*** Keys für den Org-Agenda-Mode
#+BEGIN_SRC emacs-lisp :results output silent
;(require 'org-habit)
(add-hook 'org-agenda-mode-hook 'ryo-modal-mode)
    (ryo-modal-major-mode-keys
     'org-agenda-mode
	    ("x"
	     (("s" org-save-all-org-buffers)
	      ("w" org-agenda-write)
	      ("u" org-agenda-undo)))
	    ("t" org-agenda-todo)
	    ("h" backward-char)
	    ("j" org-agenda-next-line)
	    ("k" org-agenda-previous-line)
	    ("l" forward-char)
	    ("n" org-agenda-next-item)
	    ("p" org-agenda-previous-item)
	    ("N" org-agenda-next-date-line)
	    ("P" org-agenda-previous-date-line)
	    ("c"
	     (("d" org-agenda-deadline)
	      ("o" org-agenda-open-link)
	      ("p" org-agenda-previous-date-line)
	      ("q" org-agenda-set-tags)
	      ("s" org-agenda-schedule)
	      ("t" org-agenda-todo)
	      ("w" org-agenda-refile)
	      ("z" org-agenda-add-note)
	      ("$" org-agenda-archive)
	      ("," org-agenda-priority)
	      ("c" org-agenda-goto-calendar)
     	      ("x"
     	       (("a" org-agenda-archive-default)
     	        ("c" org-agenda-columns)
       	   ;;   ("e" org-clock-modify-effort-estimate)
     	        ("TAB" org-agenda-clock-in)
     	        ("j" org-clock-goto)
     	        ("o" org-agenda-clock-out)
     	        ("s" org-agenda-archive)
     	        ("x" org-agenda-clock-cancel)
     	        ("!" org-reload)
     	        ("<" org-agenda-set-restriction-lock-from-agenda)
     	        (">" org-agenda-remove-restriction-lock)
     	        ("A" org-agenda-archive-to-archive-sibling)
     	        ("a" org-agenda-toggle-archive-tag)
     	        ("b" org-agenda-tree-to-indirect-buffer)
     	        ("e" org-agenda-set-effort)
     	        ("p" org-agenda-set-property)
     	        ("<down>" org-agenda-priority-down)
     	        ("<left>" org-agenda-do-date-earlier)
     	        ("<right>" org-agenda-do-date-later)
     	        ("<up>" org-agenda-priority-up))
     	       )))
	    ("SPC" org-agenda-show-and-scroll-up)
	    ("<backspace>" org-agenda-quit)
	    ("!" org-agenda-toggle-deadlines)
	    ("#" org-agenda-dim-blocked-tasks)
	    ("$" org-agenda-archive)
	    ("%" org-agenda-bulk-mark-regexp)
	    ("*" org-agenda-bulk-mark-all)
	    ("+" org-agenda-priority-up)
	    ("," org-agenda-priority)
	    ("-" org-agenda-priority-down)
	    ("." org-agenda-goto-today)
	    ("/" org-agenda-filter-by-tag)
	    (":" org-agenda-set-tags)
	    (";" org-timer-set-timer)
	    ("<" org-agenda-filter-by-category)
	    ("=" org-agenda-filter-by-regexp)
	    (">" org-agenda-date-prompt)
	    ("?" org-agenda-show-the-flagging-note)
;;	    ("A" org-agenda-append-agenda) ;; zum Anfang ist praktischer
	    ("B" org-agenda-bulk-action)
	    ("C" org-agenda-convert-date)
	    ("D" org-agenda-toggle-diary)
;;	    ("E" org-agenda-entry-text-mode) ;; zum Ende ist praktischer
	    ("F" org-agenda-follow-mode)
	    ("G" org-agenda-append-agenda) ;; war org-agenda-toggle-time-grid
	    ("I" org-agenda-clock-in)
	    ("M" org-agenda-phases-of-moon)
	    ("O" org-agenda-clock-out)
	    ("Q" org-agenda-Quit)
	    ("R" org-agenda-clockreport-mode)
	    ("S" org-agenda-sunrise-sunset)
	    ("T" org-agenda-show-tags)
	    ("U" org-agenda-bulk-unmark)
	    ("W" org-agenda-write)
	    ("X" org-agenda-clock-cancel)
	    ("[" org-agenda-manipulate-query-add)
	    ("]" org-agenda-manipulate-query-subtract)
	    ("^" org-agenda-filter-by-top-headline)
	    ("_" org-agenda-filter-by-effort)
;;	    ("a" org-agenda-archive-default-with-confirmation)
	    ("b" org-agenda-earlier)
	    ("d" org-recur-finish)
;;	    ("e" org-agenda-set-effort)
	    ("f" org-agenda-later)
;;	    ("g" org-agenda-redo-all) ;; führt zu Konflikten mit switch-buffer
	    ("H" org-agenda-holidays)
	    ("J" org-agenda-goto-date)
	    ("K" org-agenda-capture)
	    ("L" org-agenda-log-mode)
	    ("m" org-agenda-bulk-mark)
	    ("o" delete-other-windows)
	    ("q" org-agenda-quit)
	    ("r" org-agenda-redo :then '(beginning-of-buffer shrink-window-if-larger-than-buffer))
	    ("s" org-save-all-org-buffers)
	    ("t" org-agenda-todo)
	    ("u" universal-argument)
	    ("v" org-agenda-view-mode-dispatch)
	    ("w" org-agenda-week-view)
	    ("y" org-agenda-year-view)
	    ("z" 
	    (("z" org-agenda-add-note)
	     ("f" org-clock-convenience-fill-gap)
	     ("F" org-clock-convenience-fill-gap-both)
	     ("n" org-agenda-add-note)
	     ("i" org-agenda-clock-in)
	     ("j" org-clock-convenience-goto-ts)
	     ("o" org-agenda-clock-out)

	    ))
	    ("{" org-agenda-manipulate-query-add-re)
	    ("|" org-agenda-filter-remove-all)
	    ("}" org-agenda-manipulate-query-subtract-re)
	    ("~" org-agenda-limit-interactively)
	    ("x"
	     (
	      ;;("h" org-habit-toggle-display-in-agenda)
	      ("s" org-save-all-org-buffers)
	      ("w" org-agenda-write)
	      ("u" org-agenda-undo)))
    )
#+END_SRC

** F1 bis F12 (+ Modifiers)
   - F12 ist für die Next-Agenda reserviert.
#+begin_src emacs-lisp :results output silent
 (global-set-key (kbd "<f2>") 'toggle-window-split)
 (global-set-key (kbd "<S-f2>") 'enlarge-window-horizontally)
 (global-set-key (kbd "<s-f2>") 'shrink-window-horizontally)
 ;; (global-set-key (kbd "<s-f1>") 'pop-global-mark) ;; Jump in the document
 ;; (global-set-key (kbd "<s-f2>") 'xah-pop-local-mark-ring)
#+end_src
*** Switch windows
#+begin_src emacs-lisp :results output silent
(defun toggle-window-split ()
  (interactive)
  (if (= (count-windows) 2)
      (let* ((this-win-buffer (window-buffer))
             (next-win-buffer (window-buffer (next-window)))
             (this-win-edges (window-edges (selected-window)))
             (next-win-edges (window-edges (next-window)))
             (this-win-2nd (not (and (<= (car this-win-edges)
                                         (car next-win-edges))
                                     (<= (cadr this-win-edges)
                                         (cadr next-win-edges)))))
             (splitter
              (if (= (car this-win-edges)
                     (car (window-edges (next-window))))
                  'split-window-horizontally
                'split-window-vertically)))
        (delete-other-windows)
        (let ((first-win (selected-window)))
          (funcall splitter)
          (if this-win-2nd (other-window 1))
          (set-window-buffer (selected-window) this-win-buffer)
          (set-window-buffer (next-window) next-win-buffer)
          (select-window first-win)
          (if this-win-2nd (other-window 1))))))
#+end_src
** <escape> auf ESC
#+begin_src emacs-lisp :results output silent
(define-key key-translation-map (kbd "ESC") (kbd "C-g"))
(define-key key-translation-map (kbd "C-<escape>") (kbd "ESC"))
#+end_src
* Textbearbeitung
:PROPERTIES:
:CATEGORY: textEd
:END:
** TODO Rechtschreibung
Ich musste noch das deutsche Wörterbuch installieren, bevor es klappt: sudo apt-get install aspell-de
 #+BEGIN_SRC  emacs-lisp
(when (string-equal system-type "gnu/linux")
  (setq ispell-dictionary "deutsch8")
  (setq ispell-local-dictionary "deutsch")
  (setq flyspell-default-dictionary "deutsch8")
  (add-hook 'text-mode-hook 'flyspell-mode)
  (autoload 'flyspell-mode "flyspell" "On-the-fly ispell." t)
  (setq flyspell-issue-welcome-flag nil)
  )
 #+END_SRC
* Appearance :appearance:
** Window-Control
#+begin_src emacs-lisp :results output silent
(setq even-window-sizes 'height-only)
(setq window-combination-resize t) ;; even out split windows |  |  | -> | | | | instead of |  | | |
#+end_src
** Modus-Themes
#+begin_src emacs-lisp :results output silent
(use-package emacs
  :config
  (setq custom-safe-themes t)           ; Due to my dev needs

  (defmacro contrib/format-sexp (sexp &rest objects)
    `(eval (read (format ,(format "%S" sexp) ,@objects))))

  ;; This is currently not used in this section.  Search for it in the
  ;; section about setting fonts, `prot/font-bold-face' in particular.
  (defvar prot/modus-theme-after-load-hook nil
    "Hook that runs after loading a Modus theme.
See `prot/modus-operandi' or `prot/modus-vivendi'.")

  ;; The variables do not reveal my preferences.  Always testing things.
  (dolist (theme '("operandi" "vivendi"))
    (contrib/format-sexp
     (defun prot/modus-%1$s ()
       (setq modus-%1$s-theme-slanted-constructs t
             modus-%1$s-theme-bold-constructs t
             modus-%1$s-theme-fringes 'subtle ; {nil,'subtle,'intense}
             modus-%1$s-theme-3d-modeline nil
             modus-%1$s-theme-faint-syntax nil
             modus-%1$s-theme-intense-hl-line nil
             modus-%1$s-theme-intense-paren-match nil
             modus-%1$s-theme-prompts 'subtle ; {nil,'subtle,'intense}
             modus-%1$s-theme-completions 'moderate ; {nil,'moderate,'opinionated}
             modus-%1$s-theme-diffs 'desaturated ; {nil,'desaturated,'fg-only}
             modus-%1$s-theme-org-blocks 'greyscale ; {nil,'greyscale,'rainbow}
             modus-%1$s-theme-variable-pitch-headings t
             modus-%1$s-theme-rainbow-headings nil
             modus-%1$s-theme-section-headings nil
             modus-%1$s-theme-scale-headings t
             modus-%1$s-theme-scale-1 1.1
             modus-%1$s-theme-scale-2 1.15
             modus-%1$s-theme-scale-3 1.21
             modus-%1$s-theme-scale-4 1.27
             modus-%1$s-theme-scale-5 1.33)
       (load-theme 'modus-%1$s t)
       (run-hooks 'prot/modus-theme-after-load-hook))
     theme))

  (define-minor-mode prot/modus-themes-alt-mode
    "Override specific palette variables with custom values.

This is intended as a proof-of-concept.  It is, nonetheless, a
perfectly accessible alternative, conforming with the design
principles of the Modus themes.  It still is not as good as the
default colours."
    :init-value nil
    :global t
    (if prot/modus-themes-alt-mode
        (setq modus-operandi-theme-override-colors-alist
              '(("bg-main" . "#fefcf4")
                ("bg-dim" . "#faf6ef")
                ("bg-alt" . "#f7efe5")
                ("bg-hl-line" . "#f4f0e3")
                ("bg-active" . "#e8dfd1")
                ("bg-inactive" . "#f6ece5")
                ("bg-region" . "#c6bab1")
                ("bg-header" . "#ede3e0")
                ("bg-tab-bar" . "#dcd3d3")
                ("bg-tab-active" . "#fdf6eb")
                ("bg-tab-inactive" . "#c8bab8")
                ("fg-unfocused" . "#55556f"))
              modus-vivendi-theme-override-colors-alist
              '(("bg-main" . "#100b17")
                ("bg-dim" . "#161129")
                ("bg-alt" . "#181732")
                ("bg-hl-line" . "#191628")
                ("bg-active" . "#282e46")
                ("bg-inactive" . "#1a1e39")
                ("bg-region" . "#393a53")
                ("bg-header" . "#202037")
                ("bg-tab-bar" . "#262b41")
                ("bg-tab-active" . "#120f18")
                ("bg-tab-inactive" . "#3a3a5a")
                ("fg-unfocused" . "#9a9aab")))
      (setq modus-operandi-theme-override-colors-alist nil
            modus-vivendi-theme-override-colors-alist nil)))

  (defun prot/modus-themes-toggle (&optional arg)
    "Toggle between `prot/modus-operandi' and `prot/modus-vivendi'."
    (interactive "P")
    (if arg
        (prot/modus-themes-alt-mode 1)
      (prot/modus-themes-alt-mode -1))
    (if (eq (car custom-enabled-themes) 'modus-operandi)
        (progn
          (disable-theme 'modus-operandi)
          (prot/modus-vivendi))
      (disable-theme 'modus-vivendi)
      (prot/modus-operandi)))

  :hook (after-init-hook . prot/modus-operandi)
  :bind ("<f5>" . prot/modus-themes-toggle))
 
#+end_src
** COMMENT Style Tags based on Regular Expressions :one:
*** Code 
#+BEGIN_SRC emacs-lisp
;; (require 'org)
(set-face-attribute 'org-tag nil :height 0.5 :slant 'normal :weight 'normal :foreground "LavenderBlush3")

(add-to-list 'org-tag-faces '("@.*" . (:foreground "cyan" :height 0.8)))

;; Reset the global variable to nil, just in case org-mode has already beeen used.
(when org-tags-special-faces-re
  (setq org-tags-special-faces-re nil))

(defun org-get-tag-face (kwd)
  "Get the right face for a TODO keyword KWD.
If KWD is a number, get the corresponding match group."
  (if (numberp kwd) (setq kwd (match-string kwd)))
  (let ((special-tag-face (or (cdr (assoc kwd org-tag-faces))
                              (and (string-match "^@.*" kwd)
                                   (cdr (assoc "@.*" org-tag-faces))))))
    (or (org-face-from-face-or-color 'tag 'org-tag special-tag-face)
        'org-tag)))
#+END_SRC
*** Info from [[https://stackoverflow.com/questions/40876294/color-tags-based-on-regex-emacs-org-mode][Stackoverflow]]
The following answer uses the built-in mechanisms of org-mode. The variable org-tag-faces accepts a regexp for the tag, which is the car of the cons cell. The function org-set-tag-faces sets a global variable org-tags-special-faces-re, which combines the tags of the aforementioned cons cell(s). The global variable org-tags-special-faces-re is used by org-font-lock-add-tag-faces to re-search-forward through the org-mode buffer -- locating the matching tags and applying the appropriate face based on the function org-get-tag-face. The original version of the function org-get-tag-face looked for an exact match of the tag found (i.e., the key argument to the function assoc). The revised version of org-get-tag-face adds an additional key search for @.* and returns the proper face if the key is found -- this is necessary because the tag itself will usually look something like @home or @office, whereas our context regexp is @.*.

Wow, thank's a lot, that's cool even if I don't understand everything (my knowledges about lisp and emacs-lisp are very limited ^^). Now, say that I want to do the same with other regex, can you explain me (in the simpliest way) how do I do ? – boehm_s Dec 1 '16 at 20:43

The car of each cons cell of org-tag-faces is by its very nature a regexp, which gets processed into something that eventually looks like this: ":\\(@.*\\|TOP\\|HIGH\\|MEDIUM\\|LOW\\|NEGATIVE):" So, it is already set up to work with regexp out-of-the-box. The change that needs to be made is how org-get-tag-face locates a match within org-tag-faces. You could add additional entries to org-tag-faces with your regexp, and add additional entries to org-get-tag-face -- e.g., just above (cdr (assoc "@.*" org-tag-faces)). – lawlist Dec 1 '16 at 20:50

For example, (add-to-list 'org-tag-faces '("MYREGEX" . (:foreground "red"))) and just above (cdr (assoc "@.*" org-tag-faces)) in org-get-tag-face, insert (cdr (assoc "MYREGEX" org-tag-faces)) The function assoc is using equal to find an exact key match. – lawlist Dec 1 '16 at 20:55

I changed (cdr (assoc "@.*" org-tag-faces)) to (and (string-match "^@.*" kwd) (cdr (assoc "@.*" org-tag-faces))) to ensure that kwd is indeed a context tag before testing to see if a context tag regexp is a car of one of the cons cells that make up org-tag-faces. This will be important if you decide to add additional regexp to org-get-tag-face; e.g., adding an additional (and (string-match "MYREGEX" kwd) (cdr (assoc "MYREGEX" org-tag-faces))) – lawlist Dec 1 '16 at 23:52
** Tag Alignment :org:
Legt die Spalte fest, auf die Tags angeordnet werden sollen. Durch Schriftarten mit variablen Breiten ergibt sich allerdings nie ein einheitliches Bild. Daher setze ich den Wert auf 0, so dass die Tags direkt an den Überschriften anschließen. 

#+BEGIN_SRC emacs-lisp
(setq org-tags-column 0)
#+END_SRC
** Fonts and Faces
*** Font Weight :wissen:
    - :weight ([[https://www.gnu.org/software/emacs/manual/html_node/elisp/Face-Attributes.html][Quelle]])
      - Font weight—one of the symbols (from densest to faintest) ultra-bold, extra-bold, bold, semi-bold, normal, semi-light, light, extra-light, or ultra-light. On text terminals which support variable-brightness text, any weight greater than normal is displayed as extra bright, and any weight less than normal is displayed as half-bright. 
*** [#B] Set variable pitch font
 #+BEGIN_SRC emacs-lisp

 ;; Set variable-pitch font using customize-face variable-pitch
 ;; Set the fonts to format correctly for specific modes. Default is set for fixed
 ;; so we only need to have the exceptions
 (defun set-buffer-variable-pitch ()
   (interactive)
   (variable-pitch-mode t)
   (setq line-spacing 3)
   (set-face-attribute 'org-table nil :inherit 'fixed-pitch)
   (set-face-attribute 'org-link nil :inherit 'fixed-pitch)
   (set-face-attribute 'org-code nil :inherit 'fixed-pitch)
   (set-face-attribute 'org-block nil :inherit 'fixed-pitch)
   (set-face-attribute 'org-date nil :inherit 'fixed-pitch)
   (set-face-attribute 'org-special-keyword nil :inherit 'fixed-pitch)
   )

 (add-hook 'org-mode-hook 'set-buffer-variable-pitch)
 (add-hook 'Info-mode-hook 'set-buffer-variable-pitch)

 #+END_SRC
*** [#C] Org Meta Line (#+-Lines)
 #+BEGIN_SRC emacs-lisp
 (set-face-attribute 'org-meta-line nil :height 0.5 :slant 'normal :foreground "LavenderBlush3")
 #+END_SRC

*** [#C] Use fancy lambdas
 Ersetzt lamba ( ) mit dem Lambda-Symbol

 #+begin_src emacs-lisp
   (global-prettify-symbols-mode t)
 #+end_src

*** Encoding
    - Dieser Teil ist Windows-spezifisch
#+begin_src emacs-lisp :results output silent
(when (string-equal system-type "windows-nt")
;; --- start
  (add-to-list 'file-coding-system-alist '("\\.org" . utf-8-unix) )
(add-to-list 'file-coding-system-alist '("\\.tex" . utf-8-unix) )
(add-to-list 'file-coding-system-alist '("\\.txt" . utf-8-unix) )
(add-to-list 'file-coding-system-alist '("\\.el" . utf-8-unix) )
(add-to-list 'file-coding-system-alist '("\\.scratch" . utf-8-unix) )
(add-to-list 'file-coding-system-alist '("user_prefs" . utf-8-unix) )

(add-to-list 'process-coding-system-alist '("\\.txt" . utf-8-unix) )

(add-to-list 'network-coding-system-alist '("\\.txt" . utf-8-unix) )

(prefer-coding-system 'utf-8-unix)
(set-default-coding-systems 'utf-8-unix)
(set-terminal-coding-system 'utf-8-unix)
(set-keyboard-coding-system 'utf-8-unix)
(set-selection-coding-system 'utf-16-le)
(setq-default buffer-file-coding-system 'utf-8-unix)

;; Treat clipboard input as UTF-8 string first; compound text next, etc.
(setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING))

;; mnemonic for utf-8 is "U", which is defined in the mule.el
(setq eol-mnemonic-dos ":CRLF")
(setq eol-mnemonic-mac ":CR")
(setq eol-mnemonic-undecided ":?")
(setq eol-mnemonic-unix ":LF")

(defalias 'read-buffer-file-coding-system 'lawlist-read-buffer-file-coding-system)
(defun lawlist-read-buffer-file-coding-system ()
  (let* ((bcss (find-coding-systems-region (point-min) (point-max)))
         (css-table
          (unless (equal bcss '(undecided))
            (append '("dos" "unix" "mac")
                    (delq nil (mapcar (lambda (cs)
                                        (if (memq (coding-system-base cs) bcss)
                                            (symbol-name cs)))
                                      coding-system-list)))))
         (combined-table
          (if css-table
              (completion-table-in-turn css-table coding-system-alist)
            coding-system-alist))
         (auto-cs
          (unless find-file-literally
            (save-excursion
              (save-restriction
                (widen)
                (goto-char (point-min))
                (funcall set-auto-coding-function
                         (or buffer-file-name "") (buffer-size))))))
         (preferred 'utf-8-unix)
         (default 'utf-8-unix)
         (completion-ignore-case t)
         (completion-pcm--delim-wild-regex ; Let "u8" complete to "utf-8".
          (concat completion-pcm--delim-wild-regex
                  "\\|\\([[:alpha:]]\\)[[:digit:]]"))
         (cs (completing-read
              (format "Coding system for saving file (default %s): " default)
              combined-table
              nil t nil 'coding-system-history
              (if default (symbol-name default)))))
    (unless (zerop (length cs)) (intern cs))))
;; --- stop
  ) 
#+end_src

*** org-fontify-done-headline
    - wenn =true= dann werden Überschriften anders formatiert, wenn sie in einem =DONE=-Status sind. 
#+begin_src emacs-lisp :results output silent
(setq org-fontify-done-headline nil)
#+end_src

** Tool-/Scroll-/Menu-Bar
    I don't usually use the menu or scroll bar, and they take up useful space.
 #+begin_src emacs-lisp
   (tool-bar-mode -1)
   (menu-bar-mode 1)
   (scroll-bar-mode -1)
 #+end_src

 #+RESULTS:

 There's a tiny scroll bar that appears in the minibuffer window. This disables
 that:

 #+begin_src emacs-lisp
   (set-window-scroll-bars (minibuffer-window) nil nil)
 #+end_src

*** TODO [#D] Make menu toggle-able
** COMMENT Keyword Faces (TODO etc)
- [2022-01-17 Mo] - mehr Überlegungen zur sinnvollen Farbcodierung nötig.
- Liste mit ("KEYWORD" . face) oder ("KEYWORD" . (:property value))
#+begin_src emacs-lisp :results output silent
(setq org-todo-keyword-faces
      '(("PROJ" . (:foreground "blue"))))

#+end_src

** Split-Verhalten
   - legt die Mindestbreite fest, um horizontal zu teilen, also rechts einen neuen Buffer hinzuzufügen.
   - Mit breitem Bildschirm funktioniert der Wert 80, mit schmalem/vertikalem Layout
#+begin_src emacs-lisp :results output silent
(when (string-equal system-type "windows-nt")
(setq split-width-threshold 160)) 

(when (string-equal system-type "gnu/linux")
(setq split-width-threshold 80))
#+end_src


control the display of one buffer in a window, here the "Calendar" buffer
#+begin_src emacs-lisp :results output silent
(setq display-buffer-alist
      '(
        ("\\*Calendar.*\\'"
         (display-buffer-reuse-window display-buffer-below-selected)
         (dedicated . t)
         (window-height . fit-window-to-buffer))
        )) 
#+end_src

#+begin_src emacs-lisp :results output silent
(defun delete-other-windows-horizontally (&optional window)
  "Delete the windows in the same row with WINDOW, but not WINDOW itself.
This may be a useful alternative binding for \\[delete-other-windows]
 if you often split windows vertically."
  (interactive)
  (let* ((window (or window (selected-window)))
	 ;; ^^ the preceding Element is known to the subsequent element. "window" is either the selected window or the one passed to the function (see optional argument)
         (edges (window-edges window)) ;; assing value of =(window-edges (selected-window))= to "edges"
         (w window) ;; create variable "w" and assign value of "windows" to it 
         delenda) ;; create empty variable
    (while (not (eq (setq w (next-window w 1)) window))
      ;; for as long as we cycle throuhg the windows and we are not on the current window, ...
      (let ((e (window-edges w)))
        (when (and (= (nth 1 e) (nth 1 edges))
                   (= (nth 3 e) (nth 3 edges)))
	  ;; ... check if the window has the same edges as the current window
          (push w delenda))))
    (mapc 'delete-window delenda))) 
#+end_src
* COMMENT Notizen

** Difference in Files
18.9 Comparing Files

The command M-x diff prompts for two file names, using the minibuffer, and displays the differences between the two files in a buffer named *diff*. This works by running the diff program, using options taken from the variable diff-switches. The value of diff-switches should be a string; the default is ="-u"= to specify a unified context diff. See Diff, for more information about the diff program.

The output of the diff command is shown using a major mode called Diff mode. See Diff Mode.

A (much more sophisticated) alternative is M-x ediff (see Ediff).

The command M-x diff-backup compares a specified file with its most recent backup. If you specify the name of a backup file, diff-backup compares it with the source file that it is a backup of. In all other respects, this behaves like M-x diff.

The command M-x diff-buffer-with-file compares a specified buffer with its corresponding file. This shows you what changes you would make to the file if you save the buffer.

The command M-x compare-windows compares the text in the current window with that in the window that was the selected window before you selected the current one. (For more information about windows in Emacs, Windows.) Comparison starts at point in each window, after pushing each initial point value on the mark ring (see Mark Ring) in its respective buffer. Then it moves point forward in each window, one character at a time, until it reaches characters that don't match. Then the command exits.

If point in the two windows is followed by non-matching text when the command starts, M-x compare-windows tries heuristically to advance up to matching text in the two windows, and then exits. So if you use M-x compare-windows repeatedly, each time it either skips one matching range or finds the start of another.

With a numeric argument, compare-windows ignores changes in whitespace. If the variable compare-ignore-case is non-nil, the comparison ignores differences in case as well. If the variable compare-ignore-whitespace is non-nil, compare-windows by default ignores changes in whitespace, but a prefix argument turns that off for that single invocation of the command.

You can use M-x smerge-mode to turn on Smerge mode, a minor mode for editing output from the diff3 program. This is typically the result of a failed merge from a version control system update outside VC, due to conflicting changes to a file. Smerge mode provides commands to resolve conflicts by selecting specific changes.

See Emerge, for the Emerge facility, which provides a powerful interface for merging files. 
** Copy / Move files in dired

https://emacs.stackexchange.com/questions/5603/how-to-quickly-copy-move-file-in-emacs-dired
From the documentation:

    dired-dwim-target is a variable defined in `dired.el'. Its value is nil

    Documentation: If non-nil, Dired tries to guess a default target directory. This means: if there is a Dired buffer displayed in the next window, use its current directory, instead of this Dired buffer's current directory.

    The target is used in the prompt for file copy, rename etc.

Put this in your init file: (setq dired-dwim-target t). Then, go to dired, split your window, split-window-vertically & go to another dired directory. When you will press C to copy, the other dir in the split pane will be default destination.

* COMMENT Weg zur perfekten Config
** Look [2/3]
:PROPERTIES:
:CATEGORY: ziel
:END:
*** TODO Theme - Farben aussuchen und anpassen
*** DONE Schrift auf IBM umstellen und Größen anpassen :ARCHIVE:
*** DONE Bullets verschönern :ARCHIVE:
** Editing
*** Cheatsheet für Editing-Befehle
*** Tastenkürzel anpassen
** DONE Versionierung (git)
** Termine Synchronisieren (tickler)
** File-Struktur überarbeiten (arbeit/home/someday)
** Erweiterungen
*** Super Agenda
*** General.el
*** Hydra.el /hercules.el
*** Rechtschreibung
*** Export-Templates
*** Suche per Ivy/Helm/ripgrep
*** RSS-Reader?
*** Notmuch Emails
*** Doom-Emacs Lazy load
** Publemacs - Emacs für Publisher
*** Hilfsprogramm, das einen Entscheidungsweg über einen Minibuffer liefert
*** Tastenkürzel optimiert für Redakteure
*** Wissensmanagement in Emacs
*** Fragen
**** Was müssen Coding-Journalisten (CJs) können? 
     - Auch visuelle möglichkeiten wie 3D.js oder nur Infromationsbeschaffung über Sraping, Datenverarbeitung?
** Jouraling
*** Date-Trees
*** CaptureTemplates
*** Archivieren
*** Verschlüsselung
** Gestalten
*** Grundlagen Emacs Lisp
*** JS-Modes und Webdev-Modes

